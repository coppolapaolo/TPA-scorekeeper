<!doctype html>
<html>

<head>
    <title>Player Match</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.5.1/chart.min.js"></script>
    <style>
        .container {
            max-width: 960px;
        }

        .btn {
            height: 70px;
            vertical-align: middle;
        }
        .circle {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            border: 2px solid black;
            pointer-events: none;
        }
            .circle-kick {
            position: relative;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            border: 2px solid black;
            padding: 1px;
        }

        .circle-kick .fs-6 {
            margin: 0;
        }

        .circle label, .circle-kick label {
            margin: 0;
        }

        .white-label, .gray-label {
            /* diplay: flex; */
            justify-content: center;
            align-items: center;
            vertical-align: middle;
            height: 70px;
            font-size: 1.5em;
        }
        .white-label {
            width: 70px; 
            border: 1px solid black;
        }
        .gray-label {
            width: 35px; /* half of whiteLabel */
            background-color: lightgray;
        }
        #player1Label, #player2Label, #whiteLabel1, #whiteLabel2, #grayLabel1, #grayLabel2 {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 70px; /* Fixed height to ensure enough space for center alignment */
        }
        #circle1, #circle2 {
            position: relative;
            width: 68px;
            height: 68px;
        }
        .btn-square {
            width: 50px;
            height: 50px;
            margin: 0.3em;
        }
        table, td, th, tr {
            border: 2px solid black;
            text-align: center;
        }
        .btn-secondary {
            background-color: white !important; 
            color: black !important; 
            border-color: black !important; 
        }
        
        .btn-dark {
            background-color: gray !important; 
            border-color: lightgray !important;
            color: black !important;
        }

        .btn-match-type {
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* History mode styles */
        .history-mode #scoreButtons {
            opacity: 0.5;
            pointer-events: none;
        }
        .history-mode #playersGroup label {
            background-color: #ff9800 !important;
            border-color: #ff9800 !important;
            color: white !important;
        }
        .history-indicator {
            background-color: #ff9800;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 13px;
            text-align: center;
            margin-bottom: 10px;
            display: none;
        }
        .history-mode .history-indicator {
            display: block;
        }
        .edit-mode .history-indicator {
            display: block;
            background-color: #dc3545;
        }

        #historyNav button {
            font-size: 14px;
            padding: 8px;
        }
        #historyNav button:disabled {
            opacity: 0.4;
        }

    </style>
    <meta charset="utf-8">
</head>

<body class="p-3 m-0">
    <form id="playerForm" class="mb-5 d-flex row justify-content-center">
        <div class="form-group">
            <label for="player1">Player 1</label>
            <input type="text" class="form-control" id="player1" placeholder="Enter player name 1"
                onchange="saveNames()">
        </div>
        <div class="form-group">
            <label for="player2">Player 2</label>
            <input type="text" class="form-control" id="player2" placeholder="Enter player name 2"
                onchange="saveNames()">
        </div>
        <div class="d-flex justify-content-center mt-3 me-2">
            <input type="radio" class="btn-check" name="gameType" id="gameType1" value="8" autocomplete="off">
            <label class="btn btn-outline-primary me-2 btn-match-type" for="gameType1">8 ball</label>
            <input type="radio" class="btn-check" name="gameType" id="gameType2" value="9" autocomplete="off" checked>
            <label class="btn btn-outline-primary me-2 btn-match-type" for="gameType2">9 ball</label>
            <input type="radio" class="btn-check" name="gameType" id="gameType3"  value="10" autocomplete="off">
            <label class="btn btn-outline-primary btn-match-type" for="gameType3">10 ball</label>
        </div>
        <button type="button" class="btn btn-primary col-5" style="margin: .5em;" onclick="startMatch()">Start</button>
    </form>

    <h3 id="dateTitle" class="text-center mb-3" style="display: none;">DATA</h3>

    <div id="historyIndicator" class="history-indicator">
        Rack <span id="historyRack">1</span>, Turno <span id="historyTurn">1</span>
    </div>

    <div id="main" class="container text-center" style="display: none;">
        <div class="row  align-items-center">
            <div id="kicks" class="col-5 offset-6 mb-1">
                <span class="circle-kick">
                    <label class="fs-6 col-1">1</label>
                </span>
                <label class="fs-6 col-1">1</label>
                <span class="circle-kick">
                    <label class="fs-6 col-1">2</label>
                </span>
                <label class="fs-6 col-1">2</label>
                <label class="fs-6 col-1">2</label>
            </div>
            <div id="playersGroup" class="col-5 btn-group-vertical offset-1" role="group">
                <input type="radio" class="btn-check" name="playerOption" id="player1Option" autocomplete="off" checked>
                <label id="player1Label" class="btn btn-outline-primary mb-3" for="player1Option">Player1</label>

                <input type="radio" class="btn-check" name="playerOption" id="player2Option" autocomplete="off">
                <label id="player2Label" class="btn btn-outline-primary" for="player2Option">Player2</label>
            </div>
            <div id="divPlayers" class="col-6 align-content-center">
                <div id="divPlayerLabel1" class="row mb-3 justify-content-start align-items-center">
                    <div id="divWhiteLabel1" class="d-flex col-5 offset-1 justify-content-end">
                        <span id="circle1" class="circle">
                            <label id="whiteLabel1" class="white-label"><sup>3</sup>5M</label>
                        </span>
                    </div>
                    <div id="divGrayLabel1" class="col-3 justify-content-start">
                        <label id="grayLabel1" class="border gray-label">P</label>
                    </div>
                </div>

                <div id="divPlayerLabel2" class="row align-items-center">
                    <div id="divWhiteLabel2" class="d-flex col-5 offset-1 justify-content-end">
                        <span id="circle2" class="circle">
                            <label id="whiteLabel2" class="white-label"><sup>3</sup>5M</label>
                        </span>
                    </div>
                    <div id="divGrayLabel2" class="col-3">
                        <label id="grayLabel2" class="border gray-label">P</label>
                    </div>
                </div>
            </div>
            <div id="score" class="col-9 offset-1"><small>(0,0,NaN) <strong>0 - 0</strong> (0,0,NaN)</small></div>
        </div>
        <div id="scoreButtons" class="container mt-2" style="display: block;">
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="button1" class="btn btn-secondary btn-square">1</button>
                </div>
                <div class="col-2">
                    <button type="button" id="button2" class="btn btn-secondary btn-square">2</button>
                </div>
                <div class="col-2">
                    <button type="button" id="button3" class="btn btn-secondary btn-square">3</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="button4" class="btn btn-secondary btn-square">4</button>
                </div>
                <div class="col-2">
                    <button type="button" id="button5" class="btn btn-secondary btn-square">5</button>
                </div>
                <div class="col-2">
                    <button type="button" id="button6" class="btn btn-secondary btn-square">6</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="button7" class="btn btn-secondary btn-square">7</button>
                </div>
                <div class="col-2">
                    <button type="button" id="button8" class="btn btn-secondary btn-square">8</button>
                </div>
                <div class="col-2">
                    <button type="button" id="button9" class="btn btn-secondary btn-square">9</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="button10" class="btn btn-secondary btn-square">10</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="button0" class="btn btn-secondary btn-square">0</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="buttonM" class="btn btn-secondary btn-square">M</button>
                </div>
                <div class="col-2">
                    <button type="button" id="buttonK" class="btn btn-secondary btn-square">K</button>
                </div>
                <div class="col-2">
                    <button type="button" id="buttonS" class="btn btn-secondary btn-square">S</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="buttonP" class="btn btn-dark btn-square">P</button>
                </div>
                <div class="col-2">
                    <button type="button" id="buttonG" class="btn btn-success btn-square">G</button>
                </div>
                <div class="col-2">
                    <button type="button" id="buttonN" class="btn btn-dark btn-square">N</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="buttonn" class="btn btn-secondary btn-square">n</button>
                </div>
                <div class="col-2">
                    <button type="button" id="buttonx" class="btn btn-secondary btn-square">x</button>
                </div>
                <div class="col-2">
                    <button type="button" id="buttonp" class="btn btn-secondary btn-square">p</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-5">
                    <button type="button" id="buttonK-in" class="btn btn-secondary" style="width: 150px; height: 40px; margin: 0.3em">first shot kick-in</button>
                </div>
            </div>
        </div>
        <div id="historyNav" class="row justify-content-center mt-3" style="display: none;">
            <div class="col-4">
                <button type="button" id="btnHistoryBack" class="btn btn-warning w-100" onclick="navigateBack()">← undo</button>
            </div>
            <div class="col-4">
                <button type="button" id="btnHistoryForward" class="btn btn-warning w-100" onclick="navigateForward()">redo →</button>
            </div>
        </div>
    </div>
    <div id="endMatch" class="justify-content-center" style="display: none;">
        <button type="button" class="btn btn-primary col-7" onclick="endMatch()">End Match</button>
    </div>
    <div id="results" class="container justify-content-center mb-5 flex-column" style="display: none;">
    </div>

    <script>
        function getCookie(cname) {
            var name = cname + "=";
            var decodedCookie = decodeURIComponent(document.cookie);
            var ca = decodedCookie.split(';');
            for (var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) == ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(name) == 0) {
                    return c.substring(name.length, c.length);
                }
            }
            return "";
        }

        window.onload = function () {
            var player1 = getCookie('player1');
            if (player1 != "") {
                document.getElementById('player1').value = player1;
            }

            var player2 = getCookie('player2');
            if (player2 != "") {
                document.getElementById('player2').value = player2;
            }

            // Check for saved match state
            const savedMatch = loadMatchState();
            if (savedMatch) {
                const resume = confirm('Vuoi riprendere il match in corso?\n\n' +
                    savedMatch.players[0].name + ' vs ' + savedMatch.players[1].name + '\n' +
                    'Punteggio: ' + savedMatch.score.player1.racksWon + ' - ' + savedMatch.score.player2.racksWon);

                if (resume) {
                    resumeMatch(savedMatch);
                } else {
                    clearMatchState();
                }
            }
        };

        function saveNames() {
            var player1 = document.getElementById('player1').value;
            var player2 = document.getElementById('player2').value;
            var d = new Date();
            d.setTime(d.getTime() + (60 * 60 * 24 * 60 * 1000)); // Two months
            var expires = "expires=" + d.toUTCString();

            document.cookie = "player1=" + player1 + ";" + expires + ";path=/";
            document.cookie = "player2=" + player2 + ";" + expires + ";path=/";
        }

        function saveMatchState() {
            if (!match) return;

            // Serialize the match state (excluding methods and circular references)
            const state = {
                startDate: match.startDate,
                players: match.players,
                score: match.score,
                currentRack: match.currentRack,
                currentTurn: match.currentTurn,
                currentPlayer: match.currentPlayer,
                gameType: match.gameType,
                viewingRack: match.viewingRack,
                viewingTurn: match.viewingTurn,
                isHistoryMode: match.isHistoryMode,
                racks: match.racks.map((rack, rackIndex) => {
                    if (rack === null) return null;
                    return {
                        turns: rack.turns.map((turn, turnIndex) => {
                            if (turn === null) return null;
                            return {
                                player: turn.player,
                                breakTurn: turn.breakTurn,
                                ballsRemaining: turn.ballsRemaining,
                                pushed: turn.pushed,
                                winningTurn: turn.winningTurn,
                                score: turn.score,
                                consecutiveErrors: turn.consecutiveErrors,
                                tpaAnnotation: {
                                    totalPotted: turn.tpaAnnotation.totalPotted,
                                    breakPotted: turn.tpaAnnotation.breakPotted,
                                    missErrors: turn.tpaAnnotation.missErrors,
                                    kick: turn.tpaAnnotation.kick,
                                    pocketed: turn.tpaAnnotation.pocketed,
                                    safety: turn.tpaAnnotation.safety,
                                    push: turn.tpaAnnotation.push,
                                    safeX: turn.tpaAnnotation.safeX,
                                    noHit: turn.tpaAnnotation.noHit,
                                    kickSequence: turn.tpaAnnotation.kickSequence
                                }
                            };
                        })
                    };
                })
            };

            localStorage.setItem('tpaMatchState', JSON.stringify(state));
        }

        function loadMatchState() {
            const saved = localStorage.getItem('tpaMatchState');
            if (!saved) return null;

            try {
                const state = JSON.parse(saved);

                // Recreate Match instance
                const restoredMatch = new Match(state.players[0].name, state.players[1].name, state.gameType);
                restoredMatch.startDate = state.startDate;
                restoredMatch.score = state.score;
                restoredMatch.currentRack = state.currentRack;
                restoredMatch.currentTurn = state.currentTurn;
                restoredMatch.currentPlayer = state.currentPlayer;
                restoredMatch.viewingRack = state.viewingRack;
                restoredMatch.viewingTurn = state.viewingTurn;
                restoredMatch.isHistoryMode = state.isHistoryMode;

                // Recreate racks and turns
                restoredMatch.racks = state.racks.map((rack, rackIndex) => {
                    if (rack === null) return null;
                    return {
                        turns: rack.turns.map((turnData, turnIndex) => {
                            if (turnData === null) return null;

                            const turn = new Turn(turnData.player, turnData.breakTurn, turnData.ballsRemaining);
                            turn.pushed = turnData.pushed;
                            turn.winningTurn = turnData.winningTurn;
                            turn.score = turnData.score;
                            turn.consecutiveErrors = turnData.consecutiveErrors;

                            // Restore TPAAnnotation
                            turn.tpaAnnotation.totalPotted = turnData.tpaAnnotation.totalPotted;
                            turn.tpaAnnotation.breakPotted = turnData.tpaAnnotation.breakPotted;
                            turn.tpaAnnotation.missErrors = turnData.tpaAnnotation.missErrors;
                            turn.tpaAnnotation.kick = turnData.tpaAnnotation.kick;
                            turn.tpaAnnotation.pocketed = turnData.tpaAnnotation.pocketed;
                            turn.tpaAnnotation.safety = turnData.tpaAnnotation.safety;
                            turn.tpaAnnotation.push = turnData.tpaAnnotation.push;
                            turn.tpaAnnotation.safeX = turnData.tpaAnnotation.safeX;
                            turn.tpaAnnotation.noHit = turnData.tpaAnnotation.noHit;
                            turn.tpaAnnotation.kickSequence = turnData.tpaAnnotation.kickSequence.map(k => new KickIn(k.player, k.isFirst));

                            return turn;
                        })
                    };
                });

                // Restore previousTurn references
                for (let r = 1; r < restoredMatch.racks.length; r++) {
                    for (let t = 2; t < restoredMatch.racks[r].turns.length; t++) {
                        if (restoredMatch.racks[r].turns[t]) {
                            restoredMatch.racks[r].turns[t].previousTurn = restoredMatch.racks[r].turns[t - 1];
                        }
                    }
                }

                return restoredMatch;
            } catch (e) {
                console.error('Error loading match state:', e);
                localStorage.removeItem('tpaMatchState');
                return null;
            }
        }

        function clearMatchState() {
            localStorage.removeItem('tpaMatchState');
        }
        
        function formatDateTime(date) {
            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, '0'); // Months start from 0
            const dd = String(date.getDate()).padStart(2, '0');
            const hh = String(date.getHours()).padStart(2, '0');
            const min = String(date.getMinutes()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd} ${hh}:${min}`;
        }

        class Match {
            constructor(player1name, player2name, gameType) {
                // gameType is an integer: 8, 9, 10
                this.startDate = formatDateTime(new Date()); // Current date and time
                this.players = [
                    { name: player1name },
                    { name: player2name }
                ];
                this.score = {
                    player1: { 
                        racksWon: 0, 
                        ballsPotted: 0, 
                        missErrors: 0, 
                        breakErrors: 0, 
                        kickErrors: 0, 
                        safetyErrors: 0, 
                        positionError: 0
                    },
                    player2: { 
                        racksWon: 0, 
                        ballsPotted: 0, 
                        missErrors: 0, 
                        breakErrors: 0,
                        kickErrors: 0,
                        safetyErrors: 0,
                        positionError: 0
                    }
                };
                // add a dummy element to the racks to have the first rack with index 1 instead of 0
                this.racks = [null];
                this.currentRack = 1;
                this.currentTurn = 1;
                this.currentPlayer = 1;
                this.gameType = gameType;
                this.racks.push({turns:[null, new Turn(this.currentPlayer,true,this.gameType)]});
                // History navigation state
                this.viewingRack = null;    // null = viewing live position
                this.viewingTurn = null;
                this.isHistoryMode = false;
            }

            annotate(event) {// button listener
                // buttons have ids buttonX where X is a number or a letter
                const buttonID = event.target.id;
                const buttonValue = parseInt(buttonID.slice(6));
                if (buttonValue === 0) {
                    this.getTurn().tpaAnnotation.totalPotted = 0;
                    if (this.getTurn().isBreak()) {
                        this.getTurn().tpaAnnotation.breakPotted = this.getTurn().tpaAnnotation.breakPotted === null ? 0 : this.getTurn().tpaAnnotation.breakPotted;
                    }
                } else if (!isNaN(buttonValue)) {
                    if (this.getTurn().isBreak()) {
                        if (this.getTurn().tpaAnnotation.breakPotted === null) {
                            this.getTurn().tpaAnnotation.breakPotted = buttonValue;
                        } else {
                            this.getTurn().tpaAnnotation.totalPotted = buttonValue;
                        }
                    } else {
                        this.getTurn().tpaAnnotation.totalPotted = buttonValue;
                    }
                } else {
                    switch (buttonID) {
                        case 'buttonM':
                            this.getTurn().tpaAnnotation.missErrors = 1;
                            this.getTurn().tpaAnnotation.safety = false;
                            this.getTurn().tpaAnnotation.kick = false;
                            break;
                        case 'buttonK':
                            this.getTurn().tpaAnnotation.kick = true;
                            this.getTurn().tpaAnnotation.missErrors = 0;
                            this.getTurn().tpaAnnotation.safety = false;
                            break;
                        case 'buttonS':
                            this.getTurn().tpaAnnotation.safety = true;
                            this.getTurn().tpaAnnotation.kick = false;
                            this.getTurn().tpaAnnotation.missErrors = 0;
                            break;
                        case 'buttonG':
                            this.getTurn().setWinningTurn();
                            break;
                        case 'buttonP':
                            this.getTurn().tpaAnnotation.pocketed = this.getTurn().tpaAnnotation.pocketed === null ? true : !this.getTurn().tpaAnnotation.pocketed;
                            this.getTurn().tpaAnnotation.noHit = false;
                            break;
                        case 'buttonN':
                            this.getTurn().tpaAnnotation.noHit = this.getTurn().tpaAnnotation.noHit === null ? true : !this.getTurn().tpaAnnotation.noHit;
                            this.getTurn().tpaAnnotation.pocketed = false;
                            break;
                        case 'buttonn': 
                            this.getTurn().tpaAnnotation.missErrors =  this.getTurn().tpaAnnotation.missErrors === 2 ? 1 : 2;
                            break;
                        case 'buttonx': 
                            this.getTurn().tpaAnnotation.safeX = this.getTurn().tpaAnnotation.safeX === null ? true : !this.getTurn().tpaAnnotation.safeX;
                            this.getTurn().tpaAnnotation.push = false;
                            break;
                        case 'buttonp': 
                            this.getTurn().tpaAnnotation.push = this.getTurn().tpaAnnotation.push === null ? true : !this.getTurn().tpaAnnotation.push;
                            this.getTurn().pushed = this.getTurn().tpaAnnotation.push;
                            this.getTurn().tpaAnnotation.safeX = false;
                            break;
                    }
                }
                updateLabels(this.getTurn());
                updateButtons(this.getTurn());
                saveMatchState();

            }

            getTurn() {
                if (arguments.length === 1 && arguments[0] < 0) {//previous turn
                    return this.currentTurn+arguments[0] >= 0 ? this.racks[this.currentRack].turns[this.currentTurn + arguments[0]] : null;
                }
                return this.racks[this.currentRack].turns[this.currentTurn];
            }

            canSwitchPlayer() {
                if (!this.getTurn().hasBeenPlayed()) {
                    return this.getTurn().isBreak() && this.getTurn().tpaAnnotation.breakPotted === null;
                } else if (this.getTurn().isWinning()) {
                    return true;
                } else if (this.getTurn().isBreak() && this.getTurn().tpaAnnotation.breakPotted === 0 && this.getTurn().tpaAnnotation.totalPotted === 0) {
                    return true;
                } else if(this.getTurn().isBreak() && this.getTurn().tpaAnnotation.breakPotted > 0 && this.getTurn().tpaAnnotation.totalPotted === 0 && (this.getTurn().tpaAnnotation.noHit || this.getTurn().tpaAnnotation.pocketed)) {
                    return true;
                } else if (!this.getTurn().tpaAnnotation.kick && !this.getTurn().tpaAnnotation.safety && !this.getTurn().tpaAnnotation.missErrors && !this.getTurn().tpaAnnotation.pocketed && !this.getTurn().tpaAnnotation.noHit) {
                    return false;
                } else return true;
            }

            togglePlayer() {
            /*
            Updates the current player.

            If the previous turn was a winning turn, adds a new rack to the match and initializes a new turn.
            Otherwise, adds a new turn to the current rack.

            If a toggle was just performed (the current turn has not been played), it simply changes the player of the current turn without adding a new turn.

            Also updates the score based on the annotations and the potential winning of the turn.
            */
                const previousPlayer = this.currentPlayer;
                this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                if (!this.racks[this.currentRack].turns[this.currentTurn].hasBeenPlayed() && this.getTurn().isBreak()) {
                    this.racks[this.currentRack].turns[this.currentTurn].player = this.currentPlayer;
                } else {
                    this.updateScore(this.racks[this.currentRack].turns[this.currentTurn]);
                    const tripleFoul = this.getTurn().consecutiveErrors >= 3;
                    this.getTurn().score = scoreToString(this.score);
                    if (this.racks[this.currentRack].turns[this.currentTurn].isWinning()) {
                        this.racks.push({ turns: [null] });
                        this.currentRack++;
                        this.currentTurn = 1;
                        this.racks[this.currentRack].turns.push(new Turn(this.currentPlayer,true,this.gameType));
                    } else {
                        let ballsRemaining = this.getTurn().ballsRemaining - Math.max(this.getTurn().tpaAnnotation.totalPotted, this.getTurn().tpaAnnotation.breakPotted);
                        // Almost impossible case of all balls potted on the break and cue ball in pocket or foul
                        if (this.getTurn().tpaAnnotation.breakPotted === this.gameType && this.getTurn().tpaAnnotation.totalPotted === 0) {
                            ballsRemaining = 1;
                        }
                        let pushed = this.getTurn().isPushed() && (this.getTurn().isBreak() || (this.getTurn().isPushed() && this.getTurn().previousTurn.isBreak() && this.getTurn().previousTurn.tpaAnnotation.totalPotted === 0 && this.getTurn().tpaAnnotation.totalPotted === 0));
                        this.currentTurn++;
                        // if the game is 8 ball, the remaining balls depend on two previous turns
                        this.racks[this.currentRack].turns.push(new Turn(this.currentPlayer,false,this.gameType == 8 ? (this.currentTurn < 3 ? 8 : this.getTurn(-2).ballsRemaining - this.getTurn(-2).tpaAnnotation.totalPotted) : ballsRemaining));
                        this.getTurn().previousTurn = this.racks[this.currentRack].turns[this.currentTurn-1];
                        if (pushed) {
                            this.getTurn().push();
                        }
                        if (tripleFoul) {// if triple foul then simulates the pressure of button 0 followed by butotn G
                            this.getTurn().tpaAnnotation.totalPotted = 0;
                            this.getTurn().setWinningTurn();
                            updateLabels(this.getTurn());
                            updateButtons(this.getTurn());
                        }
                    } 
                }
            }

            updateScore(turn) {
                /* Calculate errors:
                - breakErrors: if it's a break and ended with noHit or pocketed
                - missErrors: if it's a miss. It can be 1 or 2
                - kickErrors: if it's a kick ended with noHit or pocketed
                - safetyErrors: calculated for the player of the previous turn, if they made a safety and the current player has potted at least one ball or misses an easy shot. If kick-in, it's not counted.
                - positionError: if it's not a missError of 2, if it's not safeX, hasn't won, and has potted at least one ball (unless it's a safe or a push with totalpotted > 0 but === to breakpotted). Or if pocketed is true or noHit is true, but not kick or break
                */ 
                const scorePlayer = this.score[`player${turn.player}`];
                if (turn.isWinning()) {
                    scorePlayer.racksWon++;
                }
                //update missErrors
                if (turn.tpaAnnotation.missErrors) {
                    scorePlayer.missErrors+=turn.tpaAnnotation.missErrors;
                }
                //update breakErrors. If it's a break shot (turn is break and totalPotted is zero or totalPotted is equal to breakPotted) and ended with noHit or pocketed
                if (turn.isBreakShot() && (turn.tpaAnnotation.pocketed || turn.tpaAnnotation.noHit)) {
                    if (turn.tpaAnnotation.pocketed) {
                        if (!turn.tpaAnnotation.kick && !turn.tpaAnnotation.safety && !turn.tpaAnnotation.missErrors) {
                            scorePlayer.breakErrors++;
                        } else if (turn.tpaAnnotation.missErrors){
                            scorePlayer.positionError++;
                        }
                    } else {
                        scorePlayer.breakErrors++;
                    }   
                }
                //update kickErrors
                if (turn.tpaAnnotation.kick && (turn.tpaAnnotation.noHit || turn.tpaAnnotation.pocketed)) {
                    scorePlayer.kickErrors++;
                }
                // Update safetyErrors only if it's not the first turn
                if (this.currentTurn > 1) {
                    const previousTurn = this.racks[this.currentRack].turns[this.currentTurn-1];
                    // here I assume that only kick-ins are recorded on the first shot
                    if (previousTurn.tpaAnnotation.safety) {
                        if (turn.tpaAnnotation.totalPotted > 0) {
                            if (turn.tpaAnnotation.kickSequence.length === 0) {
                                this.score[`player${previousTurn.player}`].safetyErrors++;
                            }
                        } else if (turn.tpaAnnotation.missErrors === 2) {
                            this.score[`player${previousTurn.player}`].safetyErrors++;
                        }
                    }
                }
                //update positionError
                if (turn.tpaAnnotation.missErrors !== 2 && !turn.tpaAnnotation.safeX && !turn.isWinning() && turn.tpaAnnotation.totalPotted > 0) {
                    if (turn.tpaAnnotation.breakPotted != turn.tpaAnnotation.totalPotted) {
                        scorePlayer.positionError++;
                    }
                } 
                if (turn.tpaAnnotation.pocketed && !turn.tpaAnnotation.kick && !turn.isBreak()) {
                        scorePlayer.positionError++;
                }
                scorePlayer.ballsPotted += turn.tpaAnnotation.totalPotted;
                //update consecutive errors
                if (turn.tpaAnnotation.noHit || turn.tpaAnnotation.pocketed) {
                    const previousErrors = turn.previousTurn === null ? 0 : turn.previousTurn.previousTurn === null ? 0 : turn.previousTurn.previousTurn.consecutiveErrors;
                    if (turn.tpaAnnotation.totalPotted === 0) {
                        turn.consecutiveErrors = previousErrors + 1;
                    } else {
                        turn.consecutiveErrors = 1;
                    }
                } else {
                    turn.consecutiveErrors = 0;
                }
            }

            // History navigation methods
            getViewedTurn() {
                if (this.isHistoryMode) {
                    return this.racks[this.viewingRack].turns[this.viewingTurn];
                }
                return this.getTurn();
            }

            getViewingPosition() {
                return this.isHistoryMode
                    ? { rack: this.viewingRack, turn: this.viewingTurn }
                    : { rack: this.currentRack, turn: this.currentTurn };
            }

            navigatePrevious() {
                const current = this.getViewingPosition();

                if (current.turn > 1) {
                    this.viewingRack = current.rack;
                    this.viewingTurn = current.turn - 1;
                    this.isHistoryMode = true;
                } else if (current.rack > 1) {
                    this.viewingRack = current.rack - 1;
                    this.viewingTurn = this.racks[this.viewingRack].turns.length - 1;
                    this.isHistoryMode = true;
                }
                return this.isHistoryMode;
            }

            navigateNext() {
                if (!this.isHistoryMode) return false;

                const current = this.getViewingPosition();
                const turnsInCurrentRack = this.racks[current.rack].turns.length - 1;

                if (current.turn < turnsInCurrentRack) {
                    this.viewingTurn = current.turn + 1;
                } else if (current.rack < this.currentRack) {
                    this.viewingRack = current.rack + 1;
                    this.viewingTurn = 1;
                } else {
                    this.exitHistoryMode();
                }

                if (this.viewingRack === this.currentRack && this.viewingTurn === this.currentTurn) {
                    this.exitHistoryMode();
                }

                return this.isHistoryMode;
            }

            exitHistoryMode() {
                this.isHistoryMode = false;
                this.viewingRack = null;
                this.viewingTurn = null;
            }

            canNavigatePrevious() {
                const pos = this.getViewingPosition();
                return !(pos.rack === 1 && pos.turn === 1);
            }

            canNavigateNext() {
                if (!this.isHistoryMode) return false;
                return true;
            }
        }

        class TPAAnnotation {

            constructor() {
                this.totalPotted = null;
                this.breakPotted = null;
                this.missErrors = null;// can be 0, 1, 2
                this.kick = null;
                this.pocketed = null;
                this.safety = null;
                this.push = null;
                this.safeX = null;
                this.noHit = null;
                this.kickSequence = [];
            }

            reset() {
                this.totalPotted = null;
                this.breakPotted = null;
                this.missErrors = null;
                this.kick = null;
                this.pocketed = null;
                this.safety = null;
                this.push = null;
                this.safeX = null;
                this.noHit = null;
                this.kickSequence = [];
            }

            ballsAnnotated() {
                return this.totalPotted !== null;
            }


            mainNote() {
                if (this.kick) {
                    return 'K';
                } else if (this.safety) {
                    if (this.safeX) {
                        return 'S<sup>x</sup>';
                    } else if (this.push) {
                        return 'S<sup>p</sup>';
                    } else {
                        return 'S';
                    }
                } else if (this.missErrors == 2) {
                    return 'M<sup>n</sup>';
                } else if (this.missErrors == 1) {
                    return 'M';
                }
                return '';
            }

            secondaryNote() {
                if (this.noHit) {
                    return 'N';
                } else if (this.pocketed) {
                    return 'P';
                }
                return '';
            }

            hasKickIn() {
                return this.kickSequence.length > 0;
            }
        }

        class KickIn {
            constructor(player, isFirst) {
                this.player = player;
                this.isFirst = isFirst;
            }
        }
        
        class Turn {
            constructor(player, breakTurn, ballsRemaining) {
                /* breakTurn is a boolean, ballsRemaining is an integer, tpaAnnotation is a TPAAnnotation object */
                this.player = player;
                this.breakTurn = breakTurn;
                this.ballsRemaining = ballsRemaining;
                this.tpaAnnotation = new TPAAnnotation();
                this.pushed = false;
                this.winningTurn = false;
                this.previousTurn = null;
                this.score = null;
                this.consecutiveErrors = 0;
            } 

            showButtons() {
                // Returns the buttons to be displayed
                const buttonIDs = [];
                /* There are 3 phases:
                1) Annotate the balls. If the balls are not annotated (breakPotted === null), show all buttons from 0 to ballsRemaining.
                    1.a) If it's a break (this.breakshot), there are two phases of ball annotation.
                        1.a.1) Annotate the balls potted on the break. (breakPotted === null), show all buttons from 0 to ballsRemaining.
                        1.a.2) Annotate the balls potted on the turn. (breakPotted != null and totalPotted === null), show only buttons 0 and from breakPotted to ballsRemaining. Zero if the cue ball is pocketed.
                2) Main annotation.
                3) Secondary annotation.
                */
                if (this.isWinning() || (this.tpaAnnotation.push)) {
                    if (this.isWinning() && this.previousTurn != null && (this.previousTurn.tpaAnnotation.safeX || this.previousTurn.tpaAnnotation.push || this.previousTurn.tpaAnnotation.safety) && this.tpaAnnotation.kickSequence.length === 0) {
                        buttonIDs.push('buttonK-in');
                    }           
                    return buttonIDs;
                }
                if (!this.tpaAnnotation.ballsAnnotated()) {
                    if (!this.breakTurn || this.tpaAnnotation.breakPotted === null) {
                        for (let i = 0; i <= this.ballsRemaining; i++) {
                            buttonIDs.push(`button${i}`);
                        }
                    } else {
                        buttonIDs.push('button0');
                        for (let i = match.gameType == 8 ? 0 : this.tpaAnnotation.breakPotted; i <= this.ballsRemaining; i++) {
                            buttonIDs.push(`button${i}`);
                        }
                    } 
                } else if (!this.tpaAnnotation.noHit && !this.tpaAnnotation.pocketed) {
                    if (this.breakTurn && this.tpaAnnotation.totalPotted === 0) {//special case where the break shot didn't pocket anything
                        buttonIDs.push('buttonN');
                        buttonIDs.push('buttonP');
                    } else if (!this.tpaAnnotation.safety && !this.tpaAnnotation.missErrors && !this.tpaAnnotation.kick) {
                        if (this.tpaAnnotation.breakPotted <= this.tpaAnnotation.totalPotted && this.tpaAnnotation.totalPotted > 0) {
                            buttonIDs.push('buttonG');
                            if (this.previousTurn != null && (this.previousTurn.tpaAnnotation.safeX || this.previousTurn.tpaAnnotation.push || this.previousTurn.tpaAnnotation.safety) && this.tpaAnnotation.kickSequence.length === 0) {
                                buttonIDs.push('buttonK-in');
                            }                            
                        }
                        buttonIDs.push('buttonM');
                        buttonIDs.push('buttonK');
                        buttonIDs.push('buttonS');
                        buttonIDs.push('buttonP');
                        buttonIDs.push('buttonN');
                    } else {
                        buttonIDs.push('buttonN');
                        buttonIDs.push('buttonP');
                        if (this.tpaAnnotation.safety){
                            if (this.isBreakShot() || (this.isPushed() && this.tpaAnnotation.totalPotted === 0) || (this.previousTurn != null && this.previousTurn.isBreak() && this.previousTurn.tpaAnnotation.totalPotted === 0 && this.tpaAnnotation.totalPotted === 0)) {//the push is legal on the first shot, so in three cases: 1) break with breakPotted === totalPotted, 2) push turn before pocketing any balls (totalPotted === 0), 3) previous turn was a break with totalPotted === 0 
                                buttonIDs.push('buttonp');
                            }
                            if (this.tpaAnnotation.totalPotted > 0) {
                                buttonIDs.push('buttonx');
                            }
                        } else if (this.tpaAnnotation.missErrors === 1) {
                            buttonIDs.push('buttonN');
                            buttonIDs.push('buttonP');
                            buttonIDs.push('buttonn');
                        }
                    }
                }
                return buttonIDs;
            }

            isBreak() {
                return this.breakTurn;
            }

            isBreakShot() {
                return this.isBreak() && this.tpaAnnotation.totalPotted === this.tpaAnnotation.breakPotted;
            }

            push() {
                this.pushed = true;
            }

            isPushed() {
                return this.pushed;
            }

            setWinningTurn() {
                this.winningTurn = true;
            }

            isWinning() {
                return this.winningTurn = this.winningTurn || this.ballsRemaining === 0 || this.ballsRemaining == this.tpaAnnotation.totalPotted;
            }

            hasBeenPlayed() {
                return this.tpaAnnotation.ballsAnnotated();
            }

        }

        function updateButtons(turn) {
            const buttonIDs = [];
            const buttonToShow = turn.showButtons();
            // add the ids of the buttons that are inside the scoreButtons div
            // get all the button children of scoreButtons
            const buttons = document.getElementById('scoreButtons').querySelectorAll('button');
            // for each button, add the id to the buttonIDs array
            buttons.forEach(button => buttonIDs.push(button.id));
            // Based on ballsRemaining, hide buttons with an id greater than ballsRemaining. If the button has an id buttonX with X non-numeric, ignore it.
            buttonIDs.forEach(buttonID => {
                if (buttonToShow.includes(buttonID)) {
                    document.getElementById(buttonID).style.display = 'block';
                } else {
                    document.getElementById(buttonID).style.display = 'none';
                }
            });
            
            updateSwitchPlayerStatus();
            document.getElementById('endMatch').classList.remove('d-flex');
        }

        function updateLabels(turn) {
            const playerLabel = turn.player === 1 ? 'whiteLabel1' : 'whiteLabel2';
            const grayLabel = turn.player === 1 ? 'grayLabel1' : 'grayLabel2';

            document.getElementById(turn.player === 1 ? 'circle1' : 'circle2').style.border = turn.isWinning() ? "2px solid black" : "none";

            if (turn.player === 1) {//reset of both players' labels
                document.getElementById('whiteLabel2').textContent = '';
                document.getElementById('grayLabel2').textContent = '';
                document.getElementById('circle2').style.border = "none";
                document.getElementById('kicks').textContent = '';
            }

            let whiteLabelText = '';
            if (turn.tpaAnnotation.breakPotted) {//if breakPotted is defined and not null
                whiteLabelText += `<sup>${turn.tpaAnnotation.breakPotted}</sup>`;
            }
            whiteLabelText += `${turn.tpaAnnotation.totalPotted !== null ? (turn.tpaAnnotation.totalPotted >= 0 ? turn.tpaAnnotation.totalPotted : '') : ''}`;
            whiteLabelText += ` ${turn.tpaAnnotation.mainNote()}`;
        
            document.getElementById(playerLabel).innerHTML = whiteLabelText;
        
            document.getElementById(grayLabel).textContent = turn.tpaAnnotation.secondaryNote();

            if (turn.player === 1) {
                document.getElementById('kicks').innerHTML = kickSequence(turn.tpaAnnotation.kickSequence);
            } else {
                if (turn.previousTurn) {
                    document.getElementById('kicks').innerHTML = kickSequence(turn.previousTurn.tpaAnnotation.kickSequence);
                }
                document.getElementById('kicks').innerHTML += kickSequence(turn.tpaAnnotation.kickSequence);
            }
        }
    </script>

    <script>
        let match = null;

        function startMatch() {
            // Read names directly from inputs (not cookies) to avoid timing issues
            const player1Name = document.getElementById('player1').value || 'Player 1';
            const player2Name = document.getElementById('player2').value || 'Player 2';
            saveNames(); // Save to cookies for next time
            match = new Match(player1Name, player2Name, document.querySelector('input[name="gameType"]:checked').value);

            document.getElementById('dateTitle').style.display = 'block';
            document.getElementById('main').style.display = 'block';
            document.getElementById('playerForm').style.display = 'none';
            document.getElementById('playerForm').classList.remove('d-flex');
            
            document.getElementById('dateTitle').textContent = match.startDate;
            document.getElementById('player1Label').textContent = match.players[0].name;
            document.getElementById('player2Label').textContent = match.players[1].name;

            const buttons = document.getElementById('scoreButtons').querySelectorAll('button.btn-square');
            // for each button, add match's annotate function as a listener
            buttons.forEach(button => button.addEventListener('click', match.annotate.bind(match)));
            // add a listener to kick-in button that adds the kick sequence on click
            document.getElementById('buttonK-in').addEventListener('click', function() {
                match.getTurn().tpaAnnotation.kickSequence.push(new KickIn(match.currentPlayer, true));
                updateLabels(match.getTurn());
                updateButtons(match.getTurn());
                saveMatchState();
            });

            updateLabels(match.getTurn());
            updateButtons(match.getTurn());
            initSwipeNavigation();
            saveMatchState();
        }

        function resumeMatch(restoredMatch) {
            match = restoredMatch;

            document.getElementById('dateTitle').style.display = 'block';
            document.getElementById('main').style.display = 'block';
            document.getElementById('playerForm').style.display = 'none';
            document.getElementById('playerForm').classList.remove('d-flex');

            document.getElementById('dateTitle').textContent = match.startDate;
            document.getElementById('player1Label').textContent = match.players[0].name;
            document.getElementById('player2Label').textContent = match.players[1].name;

            const buttons = document.getElementById('scoreButtons').querySelectorAll('button.btn-square');
            buttons.forEach(button => button.addEventListener('click', match.annotate.bind(match)));
            document.getElementById('buttonK-in').addEventListener('click', function() {
                match.getTurn().tpaAnnotation.kickSequence.push(new KickIn(match.currentPlayer, true));
                updateLabels(match.getTurn());
                updateButtons(match.getTurn());
                saveMatchState();
            });

            updateLabels(match.getTurn());
            updateButtons(match.getTurn());
            const scoreEl = document.getElementById('score');
            scoreEl.textContent = '';
            scoreEl.insertAdjacentHTML('beforeend', scoreToString(match.score));
            initSwipeNavigation();
            updateHistoryNavButtons();

            // Show endMatch button if current turn is a break (ready for new rack)
            if (match.getTurn().isBreak() && !match.getTurn().hasBeenPlayed()) {
                document.getElementById('endMatch').classList.add('d-flex');
            }
        }

        // Swipe navigation
        function initSwipeNavigation() {
            const mainDiv = document.getElementById('main');
            let startX = 0;
            let startY = 0;
            const SWIPE_THRESHOLD = 50;
            const SWIPE_RESTRAINT = 100;

            // Touch events for mobile
            mainDiv.addEventListener('touchstart', function(e) {
                startX = e.changedTouches[0].screenX;
                startY = e.changedTouches[0].screenY;
            }, { passive: true });

            mainDiv.addEventListener('touchend', function(e) {
                const endX = e.changedTouches[0].screenX;
                const endY = e.changedTouches[0].screenY;
                handleSwipeGesture(endX - startX, endY - startY);
            }, { passive: true });

            // Mouse events for desktop testing
            let mouseDown = false;
            let dragStartX = 0;
            let dragStartY = 0;

            mainDiv.addEventListener('mousedown', function(e) {
                mouseDown = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                console.log('drag start', dragStartX, dragStartY);
            });

            document.addEventListener('mousemove', function(e) {
                if (mouseDown) {
                    e.preventDefault(); // Prevent text selection while dragging
                }
            });

            document.addEventListener('mouseup', function(e) {
                if (mouseDown) {
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    console.log('drag end, delta', deltaX, deltaY);
                    mouseDown = false;

                    if (Math.abs(deltaX) > SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_RESTRAINT) {
                        console.log('swipe detected!', deltaX < 0 ? 'LEFT' : 'RIGHT');
                        handleSwipeGesture(deltaX, deltaY);
                    }
                }
            });

            function handleSwipeGesture(deltaX, deltaY) {
                if (Math.abs(deltaX) > SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_RESTRAINT) {
                    if (deltaX < 0) {
                        handleSwipeLeft();
                    } else {
                        handleSwipeRight();
                    }
                }
            }
        }

        function handleSwipeLeft() {
            navigateBack();
        }

        function handleSwipeRight() {
            navigateForward();
        }

        function navigateBack() {
            if (match.navigatePrevious()) {
                enterViewMode();
                updateHistoryNavButtons();
            }
        }

        function navigateForward() {
            if (match.isHistoryMode) {
                match.navigateNext();
                if (!match.isHistoryMode) {
                    exitViewMode();
                } else {
                    updateViewModeDisplay();
                }
                updateHistoryNavButtons();
            }
        }

        function updateHistoryNavButtons() {
            const historyNav = document.getElementById('historyNav');
            const btnBack = document.getElementById('btnHistoryBack');
            const btnForward = document.getElementById('btnHistoryForward');

            // Show nav buttons if there's any history (more than just the current turn)
            const hasHistory = match.currentRack > 1 || match.currentTurn > 1;
            historyNav.style.display = hasHistory ? 'flex' : 'none';

            // Update button states
            btnBack.disabled = !match.canNavigatePrevious();
            btnForward.disabled = !match.isHistoryMode;
        }

        // View mode functions
        function enterViewMode() {
            document.body.classList.add('history-mode');
            updateViewModeDisplay();
        }

        function exitViewMode() {
            document.body.classList.remove('history-mode');
            document.body.classList.remove('edit-mode');
            updateLabels(match.getTurn());
            updateButtons(match.getTurn());
            document.getElementById('score').textContent = '';
            document.getElementById('score').insertAdjacentHTML('beforeend', scoreToString(match.score));
            updateHistoryNavButtons();
        }

        function updateViewModeDisplay() {
            const viewedTurn = match.getViewedTurn();
            const pos = match.getViewingPosition();

            document.getElementById('historyRack').textContent = pos.rack;
            document.getElementById('historyTurn').textContent = pos.turn;

            displayHistoricalTurn(viewedTurn);
        }

        function displayHistoricalTurn(turn) {
            // Clear both player displays
            document.getElementById('whiteLabel1').textContent = '';
            document.getElementById('whiteLabel2').textContent = '';
            document.getElementById('grayLabel1').textContent = '';
            document.getElementById('grayLabel2').textContent = '';
            document.getElementById('circle1').style.border = 'none';
            document.getElementById('circle2').style.border = 'none';
            document.getElementById('kicks').textContent = '';

            // Display the viewed turn
            const playerLabel = turn.player === 1 ? 'whiteLabel1' : 'whiteLabel2';
            const grayLabel = turn.player === 1 ? 'grayLabel1' : 'grayLabel2';
            const circle = turn.player === 1 ? 'circle1' : 'circle2';

            let whiteLabelText = '';
            if (turn.tpaAnnotation.breakPotted) {
                whiteLabelText += '<sup>' + turn.tpaAnnotation.breakPotted + '</sup>';
            }
            whiteLabelText += (turn.tpaAnnotation.totalPotted !== null ? turn.tpaAnnotation.totalPotted : '');
            whiteLabelText += ' ' + turn.tpaAnnotation.mainNote();

            const labelEl = document.getElementById(playerLabel);
            labelEl.textContent = '';
            labelEl.insertAdjacentHTML('beforeend', whiteLabelText);

            document.getElementById(grayLabel).textContent = turn.tpaAnnotation.secondaryNote();
            document.getElementById(circle).style.border = turn.isWinning() ? "2px solid black" : "none";

            // Show kicks
            const kicksEl = document.getElementById('kicks');
            kicksEl.textContent = '';
            kicksEl.insertAdjacentHTML('beforeend', kickSequence(turn.tpaAnnotation.kickSequence));

            // Show historical score
            if (turn.score) {
                const scoreEl = document.getElementById('score');
                scoreEl.textContent = '';
                scoreEl.insertAdjacentHTML('beforeend', turn.score);
            }
        }

        // Edit mode functions
        let originalTurnSnapshot = null;
        let editingPosition = null;

        function createAnnotationSnapshot(turn) {
            return {
                totalPotted: turn.tpaAnnotation.totalPotted,
                breakPotted: turn.tpaAnnotation.breakPotted,
                missErrors: turn.tpaAnnotation.missErrors,
                kick: turn.tpaAnnotation.kick,
                pocketed: turn.tpaAnnotation.pocketed,
                safety: turn.tpaAnnotation.safety,
                push: turn.tpaAnnotation.push,
                safeX: turn.tpaAnnotation.safeX,
                noHit: turn.tpaAnnotation.noHit,
                kickSequence: turn.tpaAnnotation.kickSequence.slice(),
                winningTurn: turn.winningTurn
            };
        }

        function annotationsEqual(snap1, snap2) {
            return JSON.stringify(snap1) === JSON.stringify(snap2);
        }

        function enterEditMode() {
            if (!match.isHistoryMode) return;

            const pos = match.getViewingPosition();
            const subsequentTurns = countSubsequentTurns(pos);

            const message = 'Modificare Rack ' + pos.rack + ', Turno ' + pos.turn + '?\n\n' +
                'Questo eliminerà ' + subsequentTurns + ' turni successivi.\n\n' +
                'Continuare?';

            if (!confirm(message)) {
                return;
            }

            // Truncate all subsequent turns
            match.racks[pos.rack].turns.length = pos.turn + 1;
            match.racks.length = pos.rack + 1;

            // Set current position to this turn
            match.currentRack = pos.rack;
            match.currentTurn = pos.turn;
            match.isHistoryMode = false;

            // Reset the turn's annotation to allow re-entry
            const turn = match.getTurn();

            // Set the correct player (the one who made this turn)
            match.currentPlayer = turn.player;
            turn.tpaAnnotation.reset();
            turn.winningTurn = false;
            turn.score = null;

            // Recalculate scores up to (but not including) this turn
            recalculateAllScores();

            // Exit history mode and return to normal
            document.body.classList.remove('history-mode');

            updateLabels(turn);
            updateButtons(turn);
            updateHistoryNavButtons();
            updateSwitchPlayerStatus();
            document.getElementById('score').textContent = '';
            document.getElementById('score').insertAdjacentHTML('beforeend', scoreToString(match.score));
            saveMatchState();
        }

        function checkForEditChanges() {
            if (!editingPosition) return;

            const turn = match.getTurn();
            const currentSnapshot = createAnnotationSnapshot(turn);

            if (!annotationsEqual(originalTurnSnapshot, currentSnapshot)) {
                showEditConfirmation();
            }
        }

        function countSubsequentTurns(position) {
            let count = 0;
            count += match.racks[position.rack].turns.length - 1 - position.turn;
            for (let r = position.rack + 1; r < match.racks.length; r++) {
                count += match.racks[r].turns.length - 1;
            }
            return count;
        }

        function showEditConfirmation() {
            const pos = editingPosition;
            const subsequentTurns = countSubsequentTurns(pos);

            const message = 'Stai modificando Rack ' + pos.rack + ', Turno ' + pos.turn + '.\n\n' +
                'Questo eliminerà ' + subsequentTurns + ' turni successivi e ricalcolerà i punteggi.\n\n' +
                'Continuare?';

            if (confirm(message)) {
                applyHistoricalEdit();
            } else {
                revertEdit();
            }
        }

        function revertEdit() {
            const turn = match.getTurn();
            const snap = originalTurnSnapshot;

            turn.tpaAnnotation.totalPotted = snap.totalPotted;
            turn.tpaAnnotation.breakPotted = snap.breakPotted;
            turn.tpaAnnotation.missErrors = snap.missErrors;
            turn.tpaAnnotation.kick = snap.kick;
            turn.tpaAnnotation.pocketed = snap.pocketed;
            turn.tpaAnnotation.safety = snap.safety;
            turn.tpaAnnotation.push = snap.push;
            turn.tpaAnnotation.safeX = snap.safeX;
            turn.tpaAnnotation.noHit = snap.noHit;
            turn.tpaAnnotation.kickSequence = snap.kickSequence.slice();
            turn.winningTurn = snap.winningTurn;

            exitEditMode();
        }

        function exitEditMode() {
            document.body.classList.remove('edit-mode');
            originalTurnSnapshot = null;
            editingPosition = null;

            // Return to last rack/turn
            match.currentRack = match.racks.length - 1;
            match.currentTurn = match.racks[match.currentRack].turns.length - 1;

            updateLabels(match.getTurn());
            updateButtons(match.getTurn());
            document.getElementById('score').textContent = '';
            document.getElementById('score').insertAdjacentHTML('beforeend', scoreToString(match.score));
        }

        function applyHistoricalEdit() {
            const pos = editingPosition;

            // Truncate turns after the edited position in current rack
            match.racks[pos.rack].turns.length = pos.turn + 1;

            // Remove all subsequent racks
            match.racks.length = pos.rack + 1;

            // Recalculate all scores
            recalculateAllScores();

            // Set current position to edited turn
            match.currentRack = pos.rack;
            match.currentTurn = pos.turn;

            // Exit edit mode
            document.body.classList.remove('edit-mode');
            originalTurnSnapshot = null;
            editingPosition = null;

            // Update display
            updateLabels(match.getTurn());
            updateButtons(match.getTurn());
            document.getElementById('score').textContent = '';
            document.getElementById('score').insertAdjacentHTML('beforeend', scoreToString(match.score));
        }

        function recalculateAllScores() {
            // Reset score aggregates
            match.score = {
                player1: {
                    racksWon: 0,
                    ballsPotted: 0,
                    missErrors: 0,
                    breakErrors: 0,
                    kickErrors: 0,
                    safetyErrors: 0,
                    positionError: 0
                },
                player2: {
                    racksWon: 0,
                    ballsPotted: 0,
                    missErrors: 0,
                    breakErrors: 0,
                    kickErrors: 0,
                    safetyErrors: 0,
                    positionError: 0
                }
            };

            // Store original position
            const savedRack = match.currentRack;
            const savedTurn = match.currentTurn;

            // Iterate through all completed turns and recalculate
            for (let r = 1; r < match.racks.length; r++) {
                for (let t = 1; t < match.racks[r].turns.length; t++) {
                    const turn = match.racks[r].turns[t];

                    // Only update score for completed turns (those with score snapshot)
                    if (turn.hasBeenPlayed() && turn.score !== null) {
                        match.currentRack = r;
                        match.currentTurn = t;
                        match.updateScore(turn);
                        turn.score = scoreToString(match.score);
                    }
                }
            }

            // Restore position
            match.currentRack = savedRack;
            match.currentTurn = savedTurn;
        }

        // Function that takes a list of kick-ins and kick-outs and returns a string with the kick sequence
        function kickSequence(kickIn) {
            let kickSequence = '';
            for (let i = 0; i < kickIn.length; i++) {
                if (kickIn[i].isFirst) 
                    kickSequence += `<span class="circle-kick"><label class="fs-6 col-1">${kickIn[i].player}</label></span>`;
                else
                    kickSequence += `<label class="fs-6 col-1">${kickIn[i].player}</label>`;
            }
            return kickSequence;
        }

        function totalErrors(player) {
            return player.missErrors + player.breakErrors + player.kickErrors + player.safetyErrors + player.positionError;
        }

        function tpaScore(player) {
            return Math.trunc(player.ballsPotted/(player.ballsPotted+totalErrors(player))*1000);
        }

        function scoreToString(score) {
            return `<small>(${score.player1.ballsPotted},${totalErrors(score.player1)},${tpaScore(score.player1)}) <strong>${score.player1.racksWon} - ${score.player2.racksWon}</strong> (${score.player2.ballsPotted},${totalErrors(score.player2)},${tpaScore(score.player2)})</small>`;
        }

        function togglePlayer(event) {
            // The id of the clicked element is player1Label or player2Label. I extract the character after player and compare it with the currentPlayer. If it is different, I change the currentPlayer.
            if ((event.target.id === 'player1Label' || event.target.id === 'player2Label') && !event.target.id.includes(match.currentPlayer)) {
                match.togglePlayer();
                updateLabels(match.getTurn());
                updateButtons(match.getTurn());
                //score update
                document.getElementById('score').innerHTML = scoreToString(match.score);
                // If the current turn is a break, show endMatch, otherwise hide it
                if (match.getTurn().isBreak()) {
                    document.getElementById('endMatch').classList.add('d-flex');
                } else {
                    document.getElementById('endMatch').classList.remove('d-flex');
                }
                // Update history navigation buttons
                updateHistoryNavButtons();
                saveMatchState();
            }
        }

        function updateSwitchPlayerStatus() {
            const radioButtons = document.querySelectorAll('#playersGroup input[type="radio"]');
            const labelsForRadioButtons = document.querySelectorAll('#playersGroup label');
            const canSwitch = match.canSwitchPlayer();
        
            // Enable or disable the radio buttons based on the checkbox
            radioButtons.forEach(radio => {
                radio.disabled = !canSwitch;
                if (radio.id === `player${match.currentPlayer}Option`) {
                    radio.checked = true;
                }
            });
                
            // Update the style of the labels to reflect the disabled state
            labelsForRadioButtons.forEach(label => {
                if (!canSwitch) {
                    label.classList.add('disabled');
                } else {
                    label.classList.remove('disabled');
                }
            });
        }

        document.getElementById('playersGroup').addEventListener('click', togglePlayer);

        // Add a click listener to divPlayers that resets the current turn or enters edit mode
        document.getElementById('divPlayers').addEventListener('click', function() {
            if (match.isHistoryMode) {
                // In history mode: show confirmation and edit
                enterEditMode();
            } else {
                // Normal behavior: reset current turn
                match.getTurn().tpaAnnotation.reset();
                match.getTurn().winningTurn = false;
                updateLabels(match.getTurn());
                updateButtons(match.getTurn());
                saveMatchState();
            }
        });

        function htmlDivAnnotation(turn) {
            let kickSequence = '&nbsp;';
            for (let i = 0; i < turn.tpaAnnotation.kickSequence.length; i++) {
                if (turn.tpaAnnotation.kickSequence[i].player === turn.player) {
                    kickSequence += `<span class="circle-kick"><label class="col-1">${turn.tpaAnnotation.kickSequence[i].player}</label></span>`;
                }
            }
            let whiteLabelText = '';
            if (turn.tpaAnnotation.breakPotted) {//if breakPotted is defined and not null
                whiteLabelText += `<sup>${turn.tpaAnnotation.breakPotted}</sup>`;
            }
            whiteLabelText += `${turn.tpaAnnotation.totalPotted !== null ? (turn.tpaAnnotation.totalPotted >= 0 ? turn.tpaAnnotation.totalPotted : '') : ''}`;
            whiteLabelText += ` ${turn.tpaAnnotation.mainNote()}`;
            let circleBorder = turn.isWinning() ? "2px solid black" : "none";
            return `<div class="mb-1">${kickSequence}</div>
                    <div class="align-items-center">
                        <div class="row">
                            <div class="d-flex justify-content-center">
                                <span class="circle" style="border: ${circleBorder}">
                                    <label class="white-label d-flex">${whiteLabelText}</label>
                                </span>
                                <label class="border gray-label d-flex">${turn.tpaAnnotation.secondaryNote()}</label>
                            </div>
                        </div>
                    </div>`;

        }

        function endMatch() {
            var confirmation = window.confirm("This will end the match.\nAre you sure?");
          
            if (!confirmation) return;
            clearMatchState(); // Clear saved state since match is ending
            // Builds an HTML table with all the turns and annotations
            // Hides main and endMatch, shows results
            // Iterates through all the racks and turns and adds them to the table
            // The table has two columns, one for the first player and one for the second player
            // The headers are the names of the players
            // Each row displays the annotations for the turn
            // At the end of each rack, a wide row with the rack score is added
            const results = document.createElement('table');
            results.classList.add('table');
            results.innerHTML = `
                <thead>
                    <tr>
                        <th scope="col">${match.players[0].name}</th>
                        <th scope="col">${match.players[1].name}</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            `;
            const tbody = results.querySelector('tbody');
            for (let i = 1; i < match.racks.length-1; i++) {//when calling endMatch the last rack is always empty
                let row = document.createElement('tr');
                for (let j = 1; j < match.racks[i].turns.length; j++) {
                    const turn = match.racks[i].turns[j];
                    if (turn.player === 2) {
                        if (j === 1) {
                            row = document.createElement('tr');
                            row.innerHTML = `<td></td><td>${htmlDivAnnotation(turn)}</td>`;
                        } else {// it's not the first turn, so the second player needs to be added to the row
                            row.innerHTML += `<td>${htmlDivAnnotation(turn)}</td>`;
                        }
                    } else {// the player is the first
                        row = document.createElement('tr');
                        row.innerHTML = `<td>${htmlDivAnnotation(turn)}</td>`;                      
                    }
                    tbody.appendChild(row);
                    //if the turn is the last of the rack, add a row with the rack score
                    if (j === match.racks[i].turns.length - 1) {
                        let scoreRow = document.createElement('tr');
                        scoreRow.innerHTML = `<td colspan="2">${turn.score}</td>`;
                        tbody.appendChild(scoreRow);
                        if (i === match.racks.length - 2) {//if it's the last rack, add the final score
                            let finalScoreRow = document.createElement('tr');
                            finalScoreRow.innerHTML = `
                                <td>
                                    <div class="d-flex justify-content-between">
                                      <div>
                                        <p class="mb-0 ps-2 text-start">miss errs:</p>
                                        <p class="mb-0 ps-2 text-start">break errs:</p>
                                        <p class="mb-0 ps-2 text-start">kick errs:</p>
                                        <p class="mb-0 ps-2 text-start">safety errs:</p>
                                        <p class="mb-0 ps-2 text-start">position errs:</p>
                                      </div>
                                      <div class="text-right">
                                        <p class="mb-0 pe-2 text-end">${match.score.player1.missErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player1.breakErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player1.kickErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player1.safetyErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player1.positionError}</p>
                                      </div>
                                    </div>
                                  </td>
                                  <td>
                                    <div class="d-flex justify-content-between">
                                      <div>
                                        <p class="mb-0 ps-2 text-start">miss errs:</p>
                                        <p class="mb-0 ps-2 text-start">break errs:</p>
                                        <p class="mb-0 ps-2 text-start">kick errs:</p>
                                        <p class="mb-0 ps-2 text-start">safety errs:</p>
                                        <p class="mb-0 ps-2 text-start">position errs:
                                      </div>
                                      <div class="text-right">
                                        <p class="mb-0 pe-2 text-end">${match.score.player2.missErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player2.breakErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player2.kickErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player2.safetyErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player2.positionError}</p>
                                      </div>
                                    </div>
                                  </td>`;
                            tbody.appendChild(finalScoreRow);                    
                        }
                    }
                }
            }
            document.getElementById('results').appendChild(results);
            document.getElementById('main').style.display = 'none';
            document.getElementById('endMatch').classList.remove('d-flex');
            document.getElementById('results').style.display = 'block';

            // save the match in the google sheet
            // saves date, player1, player2, tpaScore, racksWon, ballsPotted, missErrors, breakErrors, kickErrors, safetyErrors, positionError (for both players), gameType, html table with the annotations

            //scritp url is hard-coded... :( (for now)
            const googleSheetURL = 'https://script.google.com/macros/s/AKfycbzn6HJDjup8zqvASM4-cB9zmPcPMi8h-u-iXAXaPDenkr_G9Q2Ap05mrisaWL_Fe8FK4w/exec';
            const matchData = {
                date: match.startDate,
                player1: match.players[0].name,
                player2: match.players[1].name,
                player1Score: tpaScore(match.score.player1),
                player2Score: tpaScore(match.score.player2),
                player1RacksWon: match.score.player1.racksWon,
                player2RacksWon: match.score.player2.racksWon,
                player1BallsPotted: match.score.player1.ballsPotted,
                player2BallsPotted: match.score.player2.ballsPotted,
                player1MissErrors: match.score.player1.missErrors,
                player2MissErrors: match.score.player2.missErrors,
                player1BreakErrors: match.score.player1.breakErrors,
                player2BreakErrors: match.score.player2.breakErrors,
                player1KickErrors: match.score.player1.kickErrors,
                player2KickErrors: match.score.player2.kickErrors,
                player1SafetyErrors: match.score.player1.safetyErrors,
                player2SafetyErrors: match.score.player2.safetyErrors,
                player1PositionError: match.score.player1.positionError,
                player2PositionError: match.score.player2.positionError,
                gameType: match.gameType,
                htmlTable: results.outerHTML
            };
            fetch(googleSheetURL, {
                method: 'POST',
                mode: 'no-cors',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(matchData)
            })
            .catch(error => {
                console.error('Error:', error);
            });
        }

    </script>
</body>

</html>