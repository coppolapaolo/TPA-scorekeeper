<!doctype html>
<html>

<head>
    <meta name="google" content="notranslate">
    <title>Player Match</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.5.1/chart.min.js"></script>
    <style>
        .container {
            max-width: 960px;
        }

        .btn {
            height: 70px;
            vertical-align: middle;
        }
        .circle {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            border: 2px solid black;
            pointer-events: none;
        }
        .circle-kick {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #555;
            font-size: 0.8em;
            color: #555;
        }

        .circle-kick label {
            margin: 0;
            padding: 0;
            line-height: 1;
            color: #555;
        }

        .white-label, .gray-label {
            /* diplay: flex; */
            justify-content: center;
            align-items: center;
            vertical-align: middle;
            height: 70px;
            font-size: 1.5em;
        }
        .white-label {
            width: 70px; 
            border: 1px solid black;
        }
        .gray-label {
            width: 35px; /* half of whiteLabel */
            background-color: lightgray;
        }
        #player1Label, #player2Label, #whiteLabel1, #whiteLabel2, #grayLabel1, #grayLabel2 {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 70px; /* Fixed height to ensure enough space for center alignment */
        }
        #circle1, #circle2 {
            position: relative;
            width: 68px;
            height: 68px;
        }
        .btn-square {
            width: 50px;
            height: 50px;
            margin: 0.15em;
        }
        table, td, th, tr {
            border: 2px solid black;
            text-align: center;
        }
        .btn-secondary {
            background-color: white !important; 
            color: black !important; 
            border-color: black !important; 
        }
        
        .btn-dark {
            background-color: gray !important; 
            border-color: lightgray !important;
            color: black !important;
        }

        .btn-match-type {
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* History mode styles */
        .history-mode #scoreButtons {
            opacity: 0.5;
            pointer-events: none;
        }
        .history-mode #playersGroup label {
            background-color: #ff9800 !important;
            border-color: #ff9800 !important;
            color: white !important;
        }
        .history-mode .player-name-box {
            border-color: #ff9800 !important;
            color: #ff9800 !important;
        }
        .history-mode .player-name-box.active {
            background-color: #ff9800 !important;
            border-color: #ff9800 !important;
            color: white !important;
        }
        .history-mode .gray-label-new {
            border-color: #ff9800 !important;
        }
        .history-mode .annotation-cell {
            border: none !important;
        }
        .history-mode .annotation-cell.winning {
            border: 2px solid #ff9800 !important;
            border-radius: 50% !important;
        }
        .history-indicator {
            background-color: #ff9800;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 13px;
            text-align: center;
            margin-bottom: 10px;
            display: none;
        }
        .history-mode .history-indicator {
            display: block;
        }
        .edit-mode .history-indicator {
            display: block;
            background-color: #dc3545;
        }

        #historyNav button {
            font-size: 14px;
            padding: 8px;
            color: white;
        }
        #historyNav button:disabled {
            opacity: 0.4;
        }

        /* History list items */
        .match-card {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .match-card:hover {
            background-color: #f8f9fa;
        }
        .match-card .match-date {
            font-size: 0.85em;
            color: #6c757d;
        }
        .match-card .match-score {
            font-weight: bold;
        }
        .match-card .match-tpa {
            font-size: 0.9em;
        }
        .winner {
            color: #198754;
            font-weight: bold;
        }
        .loser {
            color: #6c757d;
        }

        /* Stats cards */
        .stats-overview h4 {
            margin-bottom: 0;
        }
        .stats-overview small {
            color: #6c757d;
        }

        /* Nav buttons on player form */
        .d-flex.gap-2 .btn {
            height: auto;
            padding: 8px 16px;
        }

        /* Loading spinner */
        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }

        /* Foul indicator */
        .foul-indicator {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 0.6em;
            color: #dc3545;
            font-weight: bold;
        }
        #player1Label, #player2Label {
            position: relative;
        }

        /* Score display */
        .score-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        .score-racks {
            font-size: 1em;
        }
        .score-tpa {
            font-size: 1.1em;
            color: #555;
        }
        .tpa-value {
            font-weight: bold;
            font-size: 1.4em;
            color: #0d6efd;
        }
        .score-stats {
            font-size: 0.8em;
            color: #888;
        }
        .score-achievements {
            font-size: 0.75em;
            color: #28a745;
            margin-top: 2px;
        }

        /* New player section layout */
        .player-section {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            background: #fafafa;
            display: inline-block;
        }
        .player-name-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
        }
        .player-name-column .tpa-display {
            text-align: center;
            margin-top: 4px;
        }
        .player-name-column .be-display {
            text-align: center;
            width: auto;
        }
        .player-name-box {
            width: 100px;
            min-width: 100px;
            max-width: 100px;
            height: 80px;
            font-size: 1em;
            display: flex !important;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-name-box.active {
            background-color: #0d6efd !important;
            color: white !important;
        }
        .player-name-box.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        .player-stats-box {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .stat-cell {
            width: 60px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            font-weight: bold;
            background: transparent;
        }
        .stat-achievements {
            font-size: 0.85em;
            font-weight: bold;
            display: flex;
            align-items: center;
            padding-left: 8px;
        }
        .annotation-cell {
            width: 80px;
            min-width: 80px;
            max-width: 80px;
            height: 80px;
            min-height: 80px;
            max-height: 80px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            position: relative;
            flex-shrink: 0;
        }
        .white-label-new {
            font-size: 1.2em;
            font-weight: bold;
        }
        .gray-label-new {
            width: 40px;
            min-width: 40px;
            max-width: 40px;
            height: 80px;
            min-height: 80px;
            max-height: 80px;
            border: 1px solid #333;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #d0d0d0;
            font-size: 0.9em;
            font-weight: bold;
        }
        .annotation-cell.winning {
            border: 2px solid #333 !important;
            border-radius: 50%;
        }
        .tpa-display {
            font-size: 1.1em;
            color: #333;
        }
        .tpa-display strong {
            color: #0d6efd;
            font-size: 1.2em;
        }
        .kicks-row {
            min-height: 24px;
            width: 120px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 2px;
            font-size: 0.85em;
            color: #555;
        }
        .be-display {
            font-size: 0.85em;
            color: #555;
            margin-top: 2px;
            width: 120px;
            text-align: center;
        }

    </style>
    <meta charset="utf-8">
</head>

<body class="p-3 m-0">
    <form id="playerForm" class="mb-5 d-flex row justify-content-center">
        <div class="form-group">
            <label for="player1">Player 1</label>
            <input type="text" class="form-control" id="player1" placeholder="Enter player name 1"
                onchange="saveNames()">
        </div>
        <div class="form-group">
            <label for="player2">Player 2</label>
            <input type="text" class="form-control" id="player2" placeholder="Enter player name 2"
                onchange="saveNames()">
        </div>
        <div class="d-flex justify-content-center mt-3 me-2">
            <input type="radio" class="btn-check" name="gameType" id="gameType1" value="8" autocomplete="off">
            <label class="btn btn-outline-primary me-2 btn-match-type" for="gameType1">8 ball</label>
            <input type="radio" class="btn-check" name="gameType" id="gameType2" value="9" autocomplete="off" checked>
            <label class="btn btn-outline-primary me-2 btn-match-type" for="gameType2">9 ball</label>
            <input type="radio" class="btn-check" name="gameType" id="gameType3"  value="10" autocomplete="off">
            <label class="btn btn-outline-primary btn-match-type" for="gameType3">10 ball</label>
        </div>
        <button type="button" class="btn btn-primary col-5" style="margin: .5em;" onclick="startMatch()">Start</button>
        <div class="d-flex justify-content-center gap-2 mt-3">
            <button type="button" class="btn btn-outline-secondary" style="min-width: 100px;" onclick="showHistoryView()">
                <i class="bi bi-clock-history"></i> History
            </button>
            <button type="button" class="btn btn-outline-secondary" style="min-width: 100px;" onclick="showStatsView()">
                <i class="bi bi-graph-up"></i> Stats
            </button>
            <button type="button" class="btn btn-outline-secondary" onclick="showSettingsView()">
                <i class="bi bi-gear"></i>
            </button>
        </div>
    </form>

    <p id="dateTitle" class="text-center text-muted mb-0" style="display: none; font-size: 0.9em;">DATA</p>
    <p id="gameTypeTitle" class="text-center text-muted mb-3" style="display: none; font-size: 0.85em;"></p>

    <div id="historyIndicator" class="history-indicator">
        Rack <span id="historyRack">1</span>, Turno <span id="historyTurn">1</span>
    </div>

    <div id="main" class="container text-center" style="display: none;">
        <!-- Hidden kicks div for compatibility -->
        <div id="kicks" style="display: none;"></div>

        <!-- Hidden playersGroup for compatibility -->
        <div id="playersGroup" style="display: none;">
            <input type="radio" class="btn-check" name="playerOption" id="player1Option" autocomplete="off" checked>
            <input type="radio" class="btn-check" name="playerOption" id="player2Option" autocomplete="off">
        </div>

        <!-- Player 1 Section -->
        <div class="player-section mb-3" id="player1Section">
            <div class="d-flex align-items-stretch">
                <div class="player-name-column">
                    <label id="player1Label" class="player-name-box btn btn-outline-primary" for="player1Option" onclick="selectPlayer(1)">
                        Player1<span id="foulIndicator1" class="foul-indicator"></span>
                    </label>
                    <span class="tpa-display">TPA <strong id="player1Tpa">-</strong></span>
                    <span class="be-display" id="player1Stats">B0 E0</span>
                </div>
                <div class="player-stats-box">
                    <div class="d-flex justify-content-end">
                        <div class="stat-cell stat-racks" id="player1Racks">0</div>
                        <div class="stat-achievements text-danger" id="player1Achievements"></div>
                    </div>
                    <div class="kicks-row" id="kicks1"></div>
                    <div class="d-flex">
                        <span id="circle1" class="annotation-cell">
                            <label id="whiteLabel1" class="white-label-new"></label>
                        </span>
                        <label id="grayLabel1" class="gray-label-new"></label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Player 2 Section -->
        <div class="player-section mb-3" id="player2Section">
            <div class="d-flex align-items-stretch">
                <div class="player-name-column">
                    <label id="player2Label" class="player-name-box btn btn-outline-primary" for="player2Option" onclick="selectPlayer(2)">
                        Player2<span id="foulIndicator2" class="foul-indicator"></span>
                    </label>
                    <span class="tpa-display">TPA <strong id="player2Tpa">-</strong></span>
                    <span class="be-display" id="player2Stats">B0 E0</span>
                </div>
                <div class="player-stats-box">
                    <div class="d-flex justify-content-end">
                        <div class="stat-cell stat-racks" id="player2Racks">0</div>
                        <div class="stat-achievements text-danger" id="player2Achievements"></div>
                    </div>
                    <div class="kicks-row" id="kicks2"></div>
                    <div class="d-flex">
                        <span id="circle2" class="annotation-cell">
                            <label id="whiteLabel2" class="white-label-new"></label>
                        </span>
                        <label id="grayLabel2" class="gray-label-new"></label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Hidden score div for compatibility -->
        <div id="score" style="display: none;"></div>
        <div id="scoreButtons" class="container mt-2" style="display: block;">
            <div class="row justify-content-center mb-1">
                <div class="col-auto p-0">
                    <button type="button" id="button1" class="btn btn-secondary btn-square">1</button>
                </div>
                <div class="col-auto p-0">
                    <button type="button" id="button2" class="btn btn-secondary btn-square">2</button>
                </div>
                <div class="col-auto p-0">
                    <button type="button" id="button3" class="btn btn-secondary btn-square">3</button>
                </div>
            </div>
            <div class="row justify-content-center mb-1">
                <div class="col-auto p-0">
                    <button type="button" id="button4" class="btn btn-secondary btn-square">4</button>
                </div>
                <div class="col-auto p-0">
                    <button type="button" id="button5" class="btn btn-secondary btn-square">5</button>
                </div>
                <div class="col-auto p-0">
                    <button type="button" id="button6" class="btn btn-secondary btn-square">6</button>
                </div>
            </div>
            <div class="row justify-content-center mb-1">
                <div class="col-auto p-0">
                    <button type="button" id="button7" class="btn btn-secondary btn-square">7</button>
                </div>
                <div class="col-auto p-0">
                    <button type="button" id="button8" class="btn btn-secondary btn-square">8</button>
                </div>
                <div class="col-auto p-0">
                    <button type="button" id="button9" class="btn btn-secondary btn-square">9</button>
                </div>
            </div>
            <div class="row justify-content-center mb-1">
                <div class="col-auto p-0">
                    <button type="button" id="button10" class="btn btn-secondary btn-square">10</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-auto p-0">
                    <button type="button" id="button0" class="btn btn-secondary btn-square">0</button>
                </div>
            </div>
            <div class="row justify-content-center mb-1">
                <div class="col-auto p-0">
                    <button type="button" id="buttonM" class="btn btn-secondary btn-square">M</button>
                </div>
                <div class="col-auto p-0">
                    <button type="button" id="buttonK" class="btn btn-secondary btn-square">K</button>
                </div>
                <div class="col-auto p-0">
                    <button type="button" id="buttonS" class="btn btn-secondary btn-square">S</button>
                </div>
            </div>
            <div class="row justify-content-center mb-1">
                <div class="col-auto p-0">
                    <button type="button" id="buttonP" class="btn btn-dark btn-square">P</button>
                </div>
                <div class="col-auto p-0">
                    <button type="button" id="buttonG" class="btn btn-success btn-square">G</button>
                </div>
                <div class="col-auto p-0">
                    <button type="button" id="buttonN" class="btn btn-dark btn-square">N</button>
                </div>
            </div>
            <div class="row justify-content-center mb-1">
                <div class="col-auto p-0">
                    <button type="button" id="buttonn" class="btn btn-secondary btn-square">n</button>
                </div>
                <div class="col-auto p-0">
                    <button type="button" id="buttonx" class="btn btn-secondary btn-square">x</button>
                </div>
                <div class="col-auto p-0">
                    <button type="button" id="buttonp" class="btn btn-secondary btn-square">p</button>
                </div>
            </div>
            <div class="row justify-content-center mb-1">
                <div class="col-auto p-0">
                    <button type="button" id="buttonK-in" class="btn btn-secondary" style="width: 150px; height: 40px; margin: 0.15em">first shot kick-in</button>
                </div>
            </div>
        </div>
        <div id="historyNav" class="row justify-content-center mt-3" style="display: none;">
            <div class="col-4">
                <button type="button" id="btnHistoryBack" class="btn btn-warning w-100" onclick="navigateBack()">← undo</button>
            </div>
            <div class="col-4">
                <button type="button" id="btnHistoryForward" class="btn btn-warning w-100" onclick="navigateForward()">redo →</button>
            </div>
        </div>
    </div>
    <div id="endMatch" class="justify-content-center" style="display: none;">
        <button type="button" class="btn btn-primary col-7" onclick="endMatch()">End Match</button>
    </div>
    <div id="results" class="container justify-content-center mb-5 flex-column" style="display: none;">
    </div>

    <!-- History View -->
    <div id="historyView" class="container" style="display: none;">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h3><i class="bi bi-clock-history"></i> Match History</h3>
            <button class="btn btn-outline-secondary" onclick="showPlayerForm()">
                <i class="bi bi-arrow-left"></i> Back
            </button>
        </div>

        <!-- Filters -->
        <div class="row mb-3">
            <div class="col-6">
                <select id="historyFilterPlayer" class="form-select" onchange="loadMatchHistory()">
                    <option value="">All Players</option>
                </select>
            </div>
            <div class="col-6">
                <select id="historyFilterGame" class="form-select" onchange="loadMatchHistory()">
                    <option value="">All Games</option>
                    <option value="8">8-ball</option>
                    <option value="9">9-ball</option>
                    <option value="10">10-ball</option>
                </select>
            </div>
        </div>

        <!-- Match List -->
        <div id="historyList" class="list-group">
            <div class="loading-spinner">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        </div>

        <!-- Pagination -->
        <nav id="historyPagination" class="mt-3" style="display: none;">
            <ul class="pagination justify-content-center">
                <li class="page-item" id="prevPageItem">
                    <a class="page-link" href="#" onclick="loadMatchHistory(currentHistoryPage - 1); return false;">Previous</a>
                </li>
                <li class="page-item disabled">
                    <span class="page-link" id="pageInfo">Page 1</span>
                </li>
                <li class="page-item" id="nextPageItem">
                    <a class="page-link" href="#" onclick="loadMatchHistory(currentHistoryPage + 1); return false;">Next</a>
                </li>
            </ul>
        </nav>
    </div>

    <!-- Match Detail View -->
    <div id="matchDetailView" class="container" style="display: none;">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h3 id="matchDetailTitle">Match Details</h3>
            <div>
                <button class="btn btn-outline-danger btn-sm me-2" onclick="deleteCurrentMatch()">
                    <i class="bi bi-trash"></i> Delete
                </button>
                <button class="btn btn-outline-secondary" onclick="showHistoryView()">
                    <i class="bi bi-arrow-left"></i> Back
                </button>
            </div>
        </div>

        <!-- Match summary card -->
        <div id="matchSummaryCard" class="card mb-3">
            <div class="card-body">
                <div class="row text-center">
                    <div class="col-5">
                        <h5 id="detailPlayer1Name">Player 1</h5>
                        <h2 id="detailPlayer1Racks" class="mb-0">0</h2>
                        <small id="detailPlayer1TPA">TPA: ---</small>
                    </div>
                    <div class="col-2 d-flex align-items-center justify-content-center">
                        <span class="fs-4">vs</span>
                    </div>
                    <div class="col-5">
                        <h5 id="detailPlayer2Name">Player 2</h5>
                        <h2 id="detailPlayer2Racks" class="mb-0">0</h2>
                        <small id="detailPlayer2TPA">TPA: ---</small>
                    </div>
                </div>
                <div class="text-center mt-2">
                    <small id="detailMatchDate" class="text-muted"></small>
                    <span id="detailGameType" class="badge bg-secondary ms-2"></span>
                </div>
            </div>
        </div>

        <!-- Annotation table -->
        <div id="matchDetailTable"></div>
    </div>

    <!-- Stats View -->
    <div id="statsView" class="container" style="display: none;">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h3><i class="bi bi-graph-up"></i> Statistics</h3>
            <button class="btn btn-outline-secondary" onclick="showPlayerForm()">
                <i class="bi bi-arrow-left"></i> Back
            </button>
        </div>

        <!-- Filters -->
        <div class="row mb-2">
            <div class="col-7">
                <select id="statsPlayerSelect" class="form-select" onchange="loadPlayerStats()">
                    <option value="">Select Player</option>
                </select>
            </div>
            <div class="col-5">
                <select id="statsGameFilter" class="form-select" onchange="loadPlayerStats()">
                    <option value="">All Games</option>
                    <option value="8">8-ball</option>
                    <option value="9">9-ball</option>
                    <option value="10">10-ball</option>
                </select>
            </div>
        </div>
        <div class="row mb-2">
            <div class="col-7">
                <select id="statsTimeRange" class="form-select" onchange="onTimeRangeChange()">
                    <option value="">All time</option>
                    <option value="1m">Last month</option>
                    <option value="3m">Last 3 months</option>
                    <option value="6m">Last 6 months</option>
                    <option value="1y">Last year</option>
                    <option value="custom">Custom range</option>
                </select>
            </div>
            <div class="col-5">
                <input type="number" id="statsMinRacks" class="form-control" placeholder="Min racks" min="0" onchange="loadPlayerStats()">
            </div>
        </div>
        <div id="customDateRange" class="row mb-2" style="display: none;">
            <div class="col-6">
                <input type="date" id="statsDateFrom" class="form-control" onchange="loadPlayerStats()">
            </div>
            <div class="col-6">
                <input type="date" id="statsDateTo" class="form-control" onchange="loadPlayerStats()">
            </div>
        </div>

        <!-- Stats content -->
        <div id="statsContent" style="display: none;">
            <!-- Overview card -->
            <div class="card mb-3">
                <div class="card-header">Overview</div>
                <div class="card-body stats-overview">
                    <div class="row text-center">
                        <div class="col-4">
                            <h4 id="statsTpaAvg">---</h4>
                            <small>Avg TPA</small>
                        </div>
                        <div class="col-4">
                            <h4 id="statsWinRate">---</h4>
                            <small>Win Rate</small>
                        </div>
                        <div class="col-4">
                            <h4 id="statsMatches">---</h4>
                            <small>Matches</small>
                        </div>
                    </div>
                    <hr class="my-2">
                    <div class="row text-center">
                        <div class="col-4">
                            <h4 id="statsBreakAndRuns" class="text-success">---</h4>
                            <small>Break & Runs</small>
                        </div>
                        <div class="col-4">
                            <h4 id="statsRunOuts" class="text-success">---</h4>
                            <small>Run Outs</small>
                        </div>
                        <div class="col-4">
                            <h4 id="statsPerfectRacks" class="text-success">---</h4>
                            <small>Perfect Racks</small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- TPA Trend Chart -->
            <div class="card mb-3">
                <div class="card-header">TPA Trend</div>
                <div class="card-body">
                    <canvas id="tpaTrendChart"></canvas>
                </div>
            </div>

            <!-- Error Trend Chart -->
            <div class="card mb-3">
                <div class="card-header">Error Trend</div>
                <div class="card-body">
                    <div class="d-flex flex-wrap gap-2 mb-3" id="errorTypeFilters">
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="errMiss" value="miss" checked onchange="updateErrorTrendChart()">
                            <label class="form-check-label" for="errMiss" style="color: #dc3545;">Miss</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="errBreak" value="break" checked onchange="updateErrorTrendChart()">
                            <label class="form-check-label" for="errBreak" style="color: #fd7e14;">Break</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="errKick" value="kick" checked onchange="updateErrorTrendChart()">
                            <label class="form-check-label" for="errKick" style="color: #ffc107;">Kick</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="errSafety" value="safety" checked onchange="updateErrorTrendChart()">
                            <label class="form-check-label" for="errSafety" style="color: #20c997;">Safety</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="errPosition" value="position" checked onchange="updateErrorTrendChart()">
                            <label class="form-check-label" for="errPosition" style="color: #6f42c1;">Position</label>
                        </div>
                    </div>
                    <canvas id="errorTrendChart"></canvas>
                </div>
            </div>

            <!-- Head-to-Head Records -->
            <div class="card mb-3">
                <div class="card-header">Head-to-Head</div>
                <div class="card-body">
                    <div id="headToHeadList" class="list-group list-group-flush"></div>
                </div>
            </div>
        </div>

        <div id="statsEmpty" class="text-center text-muted py-4">
            Select a player to view statistics
        </div>
    </div>

    <!-- Settings View -->
    <div id="settingsView" class="container" style="display: none;">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h3><i class="bi bi-gear"></i> Settings</h3>
            <button class="btn btn-outline-secondary" onclick="showPlayerForm()">
                <i class="bi bi-arrow-left"></i> Back
            </button>
        </div>

        <!-- Data Management -->
        <div class="card mb-3">
            <div class="card-header">Data Management</div>
            <div class="card-body">
                <p class="text-muted small mb-3">
                    <span id="matchCount">0</span> matches saved locally
                </p>
                <button class="btn btn-primary mb-2 w-100" onclick="exportData()">
                    <i class="bi bi-download"></i> Export All Data (JSON)
                </button>
                <div class="mb-2">
                    <input type="file" id="importFile" accept=".json" class="form-control">
                </div>
                <button class="btn btn-warning w-100" onclick="importData()">
                    <i class="bi bi-upload"></i> Import Data
                </button>
            </div>
        </div>

        <!-- Display Options -->
        <div class="card mb-3">
            <div class="card-header">Display Options</div>
            <div class="card-body">
                <p class="mb-2 fw-bold small">Show during match:</p>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="showBR" onchange="saveDisplaySettings()">
                    <label class="form-check-label" for="showBR">BR (Break & Run)</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="showRO" onchange="saveDisplaySettings()">
                    <label class="form-check-label" for="showRO">RO (Run Out)</label>
                </div>
                <div class="form-check mb-3">
                    <input class="form-check-input" type="checkbox" id="showPR" onchange="saveDisplaySettings()">
                    <label class="form-check-label" for="showPR">PR (Perfect Rack)</label>
                </div>
                <p class="mb-2 fw-bold small">Error display:</p>
                <div class="form-check">
                    <input class="form-check-input" type="radio" name="errorDisplay" id="errorTotal" value="total" checked onchange="saveDisplaySettings()">
                    <label class="form-check-label" for="errorTotal">Total errors (E)</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="radio" name="errorDisplay" id="errorByType" value="byType" onchange="saveDisplaySettings()">
                    <label class="form-check-label" for="errorByType">By type (M/B/K/S/P)</label>
                </div>
            </div>
        </div>

        <!-- About / Credits -->
        <div class="card mb-3">
            <div class="card-header">About</div>
            <div class="card-body">
                <p class="mb-2"><strong>TPA Scorekeeper</strong> v1.0</p>
                <p class="text-muted small mb-2">
                    Built with love for American pool by Paolo Coppola.
                </p>
                <p class="text-muted small mb-2">
                    This app implements the <a href="https://www.accu-stats.com" target="_blank" rel="noopener">Accu-Stats</a>
                    Total Performance Average (TPA) rating system for tracking 9-ball, 8-ball, and 10-ball matches.
                </p>
                <p class="text-muted small mb-0">
                    <a href="https://github.com/coppolapaolo/TPA-scorekeeper" target="_blank" rel="noopener">
                        <i class="bi bi-github"></i> View on GitHub
                    </a>
                </p>
            </div>
        </div>

        <!-- Danger Zone -->
        <div class="card border-danger">
            <div class="card-header bg-danger text-white">Danger Zone</div>
            <div class="card-body">
                <button class="btn btn-outline-danger w-100" onclick="clearAllData()">
                    <i class="bi bi-trash"></i> Clear All Local Data
                </button>
            </div>
        </div>
    </div>

    <script>
        // Global settings for display options
        let displaySettings = {
            showBR: false,
            showRO: false,
            showPR: false,
            errorDisplay: 'total' // 'total' or 'byType'
        };
        function getCookie(cname) {
            var name = cname + "=";
            var decodedCookie = decodeURIComponent(document.cookie);
            var ca = decodedCookie.split(';');
            for (var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) == ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(name) == 0) {
                    return c.substring(name.length, c.length);
                }
            }
            return "";
        }

        window.onload = async function () {
            // Initialize IndexedDB
            tpaDB = new TPADatabase();
            try {
                await tpaDB.init();
                // Load display settings from IndexedDB
                const savedSettings = await tpaDB.getSetting('displaySettings');
                if (savedSettings) {
                    displaySettings = { ...displaySettings, ...savedSettings };
                }
            } catch (e) {
                console.error('Failed to initialize IndexedDB:', e);
            }

            var player1 = getCookie('player1');
            if (player1 != "") {
                document.getElementById('player1').value = player1;
            }

            var player2 = getCookie('player2');
            if (player2 != "") {
                document.getElementById('player2').value = player2;
            }

            // Check for saved match state
            const savedMatch = loadMatchState();
            if (savedMatch) {
                const resume = confirm('Vuoi riprendere il match in corso?\n\n' +
                    savedMatch.players[0].name + ' vs ' + savedMatch.players[1].name + '\n' +
                    'Punteggio: ' + savedMatch.score.player1.racksWon + ' - ' + savedMatch.score.player2.racksWon);

                if (resume) {
                    resumeMatch(savedMatch);
                } else {
                    clearMatchState();
                }
            }
        };

        function saveNames() {
            var player1 = document.getElementById('player1').value;
            var player2 = document.getElementById('player2').value;
            var d = new Date();
            d.setTime(d.getTime() + (60 * 60 * 24 * 60 * 1000)); // Two months
            var expires = "expires=" + d.toUTCString();

            document.cookie = "player1=" + player1 + ";" + expires + ";path=/";
            document.cookie = "player2=" + player2 + ";" + expires + ";path=/";
        }

        function saveMatchState() {
            if (!match) return;

            // Serialize the match state (excluding methods and circular references)
            const state = {
                startDate: match.startDate,
                players: match.players,
                score: match.score,
                rackErrors: match.rackErrors,
                currentRack: match.currentRack,
                currentTurn: match.currentTurn,
                currentPlayer: match.currentPlayer,
                gameType: match.gameType,
                viewingRack: match.viewingRack,
                viewingTurn: match.viewingTurn,
                isHistoryMode: match.isHistoryMode,
                racks: match.racks.map((rack, rackIndex) => {
                    if (rack === null) return null;
                    return {
                        turns: rack.turns.map((turn, turnIndex) => {
                            if (turn === null) return null;
                            return {
                                player: turn.player,
                                breakTurn: turn.breakTurn,
                                ballsRemaining: turn.ballsRemaining,
                                pushed: turn.pushed,
                                winningTurn: turn.winningTurn,
                                score: turn.score,
                                consecutiveErrors: turn.consecutiveErrors,
                                tpaAnnotation: {
                                    totalPotted: turn.tpaAnnotation.totalPotted,
                                    breakPotted: turn.tpaAnnotation.breakPotted,
                                    missErrors: turn.tpaAnnotation.missErrors,
                                    kick: turn.tpaAnnotation.kick,
                                    pocketed: turn.tpaAnnotation.pocketed,
                                    safety: turn.tpaAnnotation.safety,
                                    push: turn.tpaAnnotation.push,
                                    safeX: turn.tpaAnnotation.safeX,
                                    noHit: turn.tpaAnnotation.noHit,
                                    kickSequence: turn.tpaAnnotation.kickSequence
                                }
                            };
                        })
                    };
                })
            };

            localStorage.setItem('tpaMatchState', JSON.stringify(state));
        }

        function loadMatchState() {
            const saved = localStorage.getItem('tpaMatchState');
            if (!saved) return null;

            try {
                const state = JSON.parse(saved);

                // Recreate Match instance
                const restoredMatch = new Match(state.players[0].name, state.players[1].name, state.gameType);
                restoredMatch.startDate = state.startDate;
                restoredMatch.score = state.score;
                restoredMatch.rackErrors = state.rackErrors || { player1: 0, player2: 0 };
                restoredMatch.currentRack = state.currentRack;
                restoredMatch.currentTurn = state.currentTurn;
                restoredMatch.currentPlayer = state.currentPlayer;
                restoredMatch.viewingRack = state.viewingRack;
                restoredMatch.viewingTurn = state.viewingTurn;
                restoredMatch.isHistoryMode = state.isHistoryMode;

                // Recreate racks and turns
                restoredMatch.racks = state.racks.map((rack, rackIndex) => {
                    if (rack === null) return null;
                    return {
                        turns: rack.turns.map((turnData, turnIndex) => {
                            if (turnData === null) return null;

                            const turn = new Turn(turnData.player, turnData.breakTurn, turnData.ballsRemaining);
                            turn.pushed = turnData.pushed;
                            turn.winningTurn = turnData.winningTurn;
                            turn.score = turnData.score;
                            turn.consecutiveErrors = turnData.consecutiveErrors;

                            // Restore TPAAnnotation
                            turn.tpaAnnotation.totalPotted = turnData.tpaAnnotation.totalPotted;
                            turn.tpaAnnotation.breakPotted = turnData.tpaAnnotation.breakPotted;
                            turn.tpaAnnotation.missErrors = turnData.tpaAnnotation.missErrors;
                            turn.tpaAnnotation.kick = turnData.tpaAnnotation.kick;
                            turn.tpaAnnotation.pocketed = turnData.tpaAnnotation.pocketed;
                            turn.tpaAnnotation.safety = turnData.tpaAnnotation.safety;
                            turn.tpaAnnotation.push = turnData.tpaAnnotation.push;
                            turn.tpaAnnotation.safeX = turnData.tpaAnnotation.safeX;
                            turn.tpaAnnotation.noHit = turnData.tpaAnnotation.noHit;
                            turn.tpaAnnotation.kickSequence = turnData.tpaAnnotation.kickSequence.map(k => new KickIn(k.player, k.isFirst));

                            return turn;
                        })
                    };
                });

                // Restore previousTurn references
                for (let r = 1; r < restoredMatch.racks.length; r++) {
                    for (let t = 2; t < restoredMatch.racks[r].turns.length; t++) {
                        if (restoredMatch.racks[r].turns[t]) {
                            restoredMatch.racks[r].turns[t].previousTurn = restoredMatch.racks[r].turns[t - 1];
                        }
                    }
                }

                return restoredMatch;
            } catch (e) {
                console.error('Error loading match state:', e);
                localStorage.removeItem('tpaMatchState');
                return null;
            }
        }

        function clearMatchState() {
            localStorage.removeItem('tpaMatchState');
        }
        
        function formatDateTime(date) {
            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, '0'); // Months start from 0
            const dd = String(date.getDate()).padStart(2, '0');
            const hh = String(date.getHours()).padStart(2, '0');
            const min = String(date.getMinutes()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd} ${hh}:${min}`;
        }

        class Match {
            constructor(player1name, player2name, gameType) {
                // gameType is an integer: 8, 9, 10
                this.startDate = formatDateTime(new Date()); // Current date and time
                this.players = [
                    { name: player1name },
                    { name: player2name }
                ];
                this.score = {
                    player1: {
                        racksWon: 0,
                        ballsPotted: 0,
                        missErrors: 0,
                        breakErrors: 0,
                        kickErrors: 0,
                        safetyErrors: 0,
                        positionError: 0,
                        runOuts: 0,
                        breakAndRuns: 0,
                        perfectRacks: 0
                    },
                    player2: {
                        racksWon: 0,
                        ballsPotted: 0,
                        missErrors: 0,
                        breakErrors: 0,
                        kickErrors: 0,
                        safetyErrors: 0,
                        positionError: 0,
                        runOuts: 0,
                        breakAndRuns: 0,
                        perfectRacks: 0
                    }
                };
                // add a dummy element to the racks to have the first rack with index 1 instead of 0
                this.racks = [null];
                this.currentRack = 1;
                this.currentTurn = 1;
                // Track errors per rack for perfect rack detection
                this.rackErrors = { player1: 0, player2: 0 };
                this.currentPlayer = 1;
                this.gameType = gameType;
                this.racks.push({turns:[null, new Turn(this.currentPlayer,true,this.gameType)]});
                // History navigation state
                this.viewingRack = null;    // null = viewing live position
                this.viewingTurn = null;
                this.isHistoryMode = false;
            }

            annotate(event) {// button listener
                // buttons have ids buttonX where X is a number or a letter
                const buttonID = event.target.id;
                const buttonValue = parseInt(buttonID.slice(6));
                if (buttonValue === 0) {
                    this.getTurn().tpaAnnotation.totalPotted = 0;
                    if (this.getTurn().isBreak()) {
                        this.getTurn().tpaAnnotation.breakPotted = this.getTurn().tpaAnnotation.breakPotted === null ? 0 : this.getTurn().tpaAnnotation.breakPotted;
                    }
                } else if (!isNaN(buttonValue)) {
                    if (this.getTurn().isBreak()) {
                        if (this.getTurn().tpaAnnotation.breakPotted === null) {
                            this.getTurn().tpaAnnotation.breakPotted = buttonValue;
                        } else {
                            this.getTurn().tpaAnnotation.totalPotted = buttonValue;
                        }
                    } else {
                        this.getTurn().tpaAnnotation.totalPotted = buttonValue;
                    }
                } else {
                    switch (buttonID) {
                        case 'buttonM':
                            this.getTurn().tpaAnnotation.missErrors = 1;
                            this.getTurn().tpaAnnotation.safety = false;
                            this.getTurn().tpaAnnotation.kick = false;
                            break;
                        case 'buttonK':
                            this.getTurn().tpaAnnotation.kick = true;
                            this.getTurn().tpaAnnotation.missErrors = 0;
                            this.getTurn().tpaAnnotation.safety = false;
                            break;
                        case 'buttonS':
                            this.getTurn().tpaAnnotation.safety = true;
                            this.getTurn().tpaAnnotation.kick = false;
                            this.getTurn().tpaAnnotation.missErrors = 0;
                            break;
                        case 'buttonG':
                            this.getTurn().setWinningTurn();
                            break;
                        case 'buttonP':
                            this.getTurn().tpaAnnotation.pocketed = this.getTurn().tpaAnnotation.pocketed === null ? true : !this.getTurn().tpaAnnotation.pocketed;
                            this.getTurn().tpaAnnotation.noHit = false;
                            break;
                        case 'buttonN':
                            this.getTurn().tpaAnnotation.noHit = this.getTurn().tpaAnnotation.noHit === null ? true : !this.getTurn().tpaAnnotation.noHit;
                            this.getTurn().tpaAnnotation.pocketed = false;
                            break;
                        case 'buttonn': 
                            this.getTurn().tpaAnnotation.missErrors =  this.getTurn().tpaAnnotation.missErrors === 2 ? 1 : 2;
                            break;
                        case 'buttonx': 
                            this.getTurn().tpaAnnotation.safeX = this.getTurn().tpaAnnotation.safeX === null ? true : !this.getTurn().tpaAnnotation.safeX;
                            this.getTurn().tpaAnnotation.push = false;
                            break;
                        case 'buttonp': 
                            this.getTurn().tpaAnnotation.push = this.getTurn().tpaAnnotation.push === null ? true : !this.getTurn().tpaAnnotation.push;
                            this.getTurn().pushed = this.getTurn().tpaAnnotation.push;
                            this.getTurn().tpaAnnotation.safeX = false;
                            break;
                    }
                }
                updateLabels(this.getTurn());
                updateButtons(this.getTurn());
                saveMatchState();

            }

            getTurn() {
                if (arguments.length === 1 && arguments[0] < 0) {//previous turn
                    return this.currentTurn+arguments[0] >= 0 ? this.racks[this.currentRack].turns[this.currentTurn + arguments[0]] : null;
                }
                return this.racks[this.currentRack].turns[this.currentTurn];
            }

            canSwitchPlayer() {
                if (!this.getTurn().hasBeenPlayed()) {
                    return this.getTurn().isBreak() && this.getTurn().tpaAnnotation.breakPotted === null;
                } else if (this.getTurn().isWinning()) {
                    return true;
                } else if (this.getTurn().isBreak() && this.getTurn().tpaAnnotation.breakPotted === 0 && this.getTurn().tpaAnnotation.totalPotted === 0) {
                    return true;
                } else if(this.getTurn().isBreak() && this.getTurn().tpaAnnotation.breakPotted > 0 && this.getTurn().tpaAnnotation.totalPotted === 0 && (this.getTurn().tpaAnnotation.noHit || this.getTurn().tpaAnnotation.pocketed)) {
                    return true;
                } else if (!this.getTurn().tpaAnnotation.kick && !this.getTurn().tpaAnnotation.safety && !this.getTurn().tpaAnnotation.missErrors && !this.getTurn().tpaAnnotation.pocketed && !this.getTurn().tpaAnnotation.noHit) {
                    return false;
                } else return true;
            }

            togglePlayer() {
            /*
            Updates the current player.

            If the previous turn was a winning turn, adds a new rack to the match and initializes a new turn.
            Otherwise, adds a new turn to the current rack.

            If a toggle was just performed (the current turn has not been played), it simply changes the player of the current turn without adding a new turn.

            Also updates the score based on the annotations and the potential winning of the turn.
            */
                const previousPlayer = this.currentPlayer;
                this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                if (!this.racks[this.currentRack].turns[this.currentTurn].hasBeenPlayed() && this.getTurn().isBreak()) {
                    this.racks[this.currentRack].turns[this.currentTurn].player = this.currentPlayer;
                } else {
                    this.updateScore(this.racks[this.currentRack].turns[this.currentTurn]);
                    const tripleFoul = this.gameType !== 8 && this.getTurn().consecutiveErrors >= 3;
                    this.getTurn().score = scoreToString(this.score);
                    if (this.racks[this.currentRack].turns[this.currentTurn].isWinning()) {
                        // Detect achievements before creating new rack
                        this.detectRackAchievements(this.getTurn());
                        this.racks.push({ turns: [null] });
                        this.currentRack++;
                        this.currentTurn = 1;
                        // Reset per-rack error tracking
                        this.rackErrors = { player1: 0, player2: 0 };
                        this.racks[this.currentRack].turns.push(new Turn(this.currentPlayer,true,this.gameType));
                    } else {
                        let ballsRemaining = this.getTurn().ballsRemaining - Math.max(this.getTurn().tpaAnnotation.totalPotted, this.getTurn().tpaAnnotation.breakPotted);
                        // Almost impossible case of all balls potted on the break and cue ball in pocket or foul
                        if (this.getTurn().tpaAnnotation.breakPotted === this.gameType && this.getTurn().tpaAnnotation.totalPotted === 0) {
                            ballsRemaining = 1;
                        }
                        let pushed = this.getTurn().isPushed() && (this.getTurn().isBreak() || (this.getTurn().isPushed() && this.getTurn().previousTurn.isBreak() && this.getTurn().previousTurn.tpaAnnotation.totalPotted === 0 && this.getTurn().tpaAnnotation.totalPotted === 0));
                        this.currentTurn++;
                        // if the game is 8 ball, the remaining balls depend on two previous turns
                        this.racks[this.currentRack].turns.push(new Turn(this.currentPlayer,false,this.gameType == 8 ? (this.currentTurn < 3 ? 8 : this.getTurn(-2).ballsRemaining - this.getTurn(-2).tpaAnnotation.totalPotted) : ballsRemaining));
                        this.getTurn().previousTurn = this.racks[this.currentRack].turns[this.currentTurn-1];
                        if (pushed) {
                            this.getTurn().push();
                        }
                        if (tripleFoul) {// if triple foul then simulates the pressure of button 0 followed by butotn G
                            this.getTurn().tpaAnnotation.totalPotted = 0;
                            this.getTurn().setWinningTurn();
                            updateLabels(this.getTurn());
                            updateButtons(this.getTurn());
                        }
                    } 
                }
            }

            updateScore(turn) {
                /* Calculate errors:
                - breakErrors: if it's a break and ended with noHit or pocketed
                - missErrors: if it's a miss. It can be 1 or 2
                - kickErrors: if it's a kick ended with noHit or pocketed
                - safetyErrors: calculated for the player of the previous turn, if they made a safety and the current player has potted at least one ball or misses an easy shot. If kick-in, it's not counted.
                - positionError: if it's not a missError of 2, if it's not safeX, hasn't won, and has potted at least one ball (unless it's a safe or a push with totalpotted > 0 but === to breakpotted). Or if pocketed is true or noHit is true, but not kick or break
                */ 
                const scorePlayer = this.score[`player${turn.player}`];
                if (turn.isWinning()) {
                    scorePlayer.racksWon++;
                }
                //update missErrors
                if (turn.tpaAnnotation.missErrors) {
                    scorePlayer.missErrors+=turn.tpaAnnotation.missErrors;
                }
                //update breakErrors. If it's a break and ended with noHit or pocketed
                // Break error if: foul on break OR foul before making any balls after break
                // (totalPotted <= breakPotted means no balls made after the break)
                if (turn.isBreak() && (turn.tpaAnnotation.pocketed || turn.tpaAnnotation.noHit)) {
                    const noExtraBalls = turn.tpaAnnotation.totalPotted <= (turn.tpaAnnotation.breakPotted || 0);
                    if (noExtraBalls) {
                        // Foul on break or immediately after - break error
                        scorePlayer.breakErrors++;
                    } else {
                        // Made balls after break then fouled - position error
                        scorePlayer.positionError++;
                    }
                }
                //update kickErrors
                if (turn.tpaAnnotation.kick && (turn.tpaAnnotation.noHit || turn.tpaAnnotation.pocketed)) {
                    scorePlayer.kickErrors++;
                }
                // Update safetyErrors only if it's not the first turn
                if (this.currentTurn > 1) {
                    const previousTurn = this.racks[this.currentRack].turns[this.currentTurn-1];
                    // here I assume that only kick-ins are recorded on the first shot
                    if (previousTurn.tpaAnnotation.safety) {
                        if (turn.tpaAnnotation.totalPotted > 0) {
                            if (turn.tpaAnnotation.kickSequence.length === 0) {
                                this.score[`player${previousTurn.player}`].safetyErrors++;
                            }
                        } else if (turn.tpaAnnotation.missErrors === 2) {
                            this.score[`player${previousTurn.player}`].safetyErrors++;
                        }
                    }
                }
                //update positionError
                if (turn.tpaAnnotation.missErrors !== 2 && !turn.tpaAnnotation.safeX && !turn.isWinning() && turn.tpaAnnotation.totalPotted > 0) {
                    if (turn.tpaAnnotation.breakPotted != turn.tpaAnnotation.totalPotted) {
                        scorePlayer.positionError++;
                    }
                } 
                if (turn.tpaAnnotation.pocketed && !turn.tpaAnnotation.kick && !turn.isBreak()) {
                        scorePlayer.positionError++;
                }
                scorePlayer.ballsPotted += turn.tpaAnnotation.totalPotted;
                //update consecutive errors
                if (turn.tpaAnnotation.noHit || turn.tpaAnnotation.pocketed) {
                    const previousErrors = turn.previousTurn === null ? 0 : turn.previousTurn.previousTurn === null ? 0 : turn.previousTurn.previousTurn.consecutiveErrors;
                    if (turn.tpaAnnotation.totalPotted === 0) {
                        turn.consecutiveErrors = previousErrors + 1;
                    } else {
                        turn.consecutiveErrors = 1;
                    }
                } else {
                    turn.consecutiveErrors = 0;
                }

                // Track per-rack errors for perfect rack detection
                let turnErrors = 0;
                // missErrors
                if (turn.tpaAnnotation.missErrors) {
                    turnErrors += turn.tpaAnnotation.missErrors;
                }
                // breakErrors - same logic as updateScore
                if (turn.isBreak() && (turn.tpaAnnotation.pocketed || turn.tpaAnnotation.noHit)) {
                    turnErrors++; // break error or position error from break foul
                }
                // kickErrors
                if (turn.tpaAnnotation.kick && (turn.tpaAnnotation.noHit || turn.tpaAnnotation.pocketed)) {
                    turnErrors++;
                }
                // positionError (same logic as above)
                if (turn.tpaAnnotation.missErrors !== 2 && !turn.tpaAnnotation.safeX && !turn.isWinning() && turn.tpaAnnotation.totalPotted > 0) {
                    if (turn.tpaAnnotation.breakPotted != turn.tpaAnnotation.totalPotted) {
                        turnErrors++;
                    }
                }
                if (turn.tpaAnnotation.pocketed && !turn.tpaAnnotation.kick && !turn.isBreak()) {
                    turnErrors++;
                }
                this.rackErrors[`player${turn.player}`] += turnErrors;

                // safetyErrors are attributed to previous turn's player
                if (this.currentTurn > 1) {
                    const previousTurn = this.racks[this.currentRack].turns[this.currentTurn-1];
                    if (previousTurn.tpaAnnotation.safety) {
                        if ((turn.tpaAnnotation.totalPotted > 0 && turn.tpaAnnotation.kickSequence.length === 0) ||
                            turn.tpaAnnotation.missErrors === 2) {
                            this.rackErrors[`player${previousTurn.player}`]++;
                        }
                    }
                }
            }

            detectRackAchievements(winningTurn) {
                // Called when a rack is won, before creating new rack
                if (!winningTurn.isWinning()) return;

                const winningPlayer = winningTurn.player;
                const scorePlayer = this.score[`player${winningPlayer}`];
                const rack = this.racks[this.currentRack];

                // Check Break & Run: all turns belong to breaking player
                const isBreakAndRun = this.checkBreakAndRun(rack, winningPlayer);

                // Check Run Out: not a break-and-run, opponent had error before our run
                const isRunOut = !isBreakAndRun && this.checkRunOut(rack, winningPlayer);

                // Check Perfect Rack: no errors by winning player in this rack
                const isPerfectRack = this.rackErrors[`player${winningPlayer}`] === 0;

                if (isBreakAndRun) {
                    scorePlayer.breakAndRuns++;
                }
                if (isRunOut) {
                    scorePlayer.runOuts++;
                }
                if (isPerfectRack) {
                    scorePlayer.perfectRacks++;
                }
            }

            checkBreakAndRun(rack, winningPlayer) {
                // First turn must be break by winning player, all turns must be by same player
                const breakTurn = rack.turns[1];
                if (!breakTurn || breakTurn.player !== winningPlayer || !breakTurn.isBreak()) {
                    return false;
                }
                for (let i = 1; i < rack.turns.length; i++) {
                    if (rack.turns[i] && rack.turns[i].player !== winningPlayer) {
                        return false;
                    }
                }
                return true;
            }

            checkRunOut(rack, winningPlayer) {
                // Run Out: winning player cleared the table in exactly ONE turn
                // after opponent's error (not a break-and-run)

                // Count winning player's turns in this rack
                let winningPlayerTurns = 0;
                for (let i = 1; i < rack.turns.length; i++) {
                    const t = rack.turns[i];
                    if (t && t.player === winningPlayer) {
                        winningPlayerTurns++;
                    }
                }

                // Run out = winning player had exactly ONE turn (the winning turn)
                // and opponent had at least one turn (which means opponent broke or played)
                return winningPlayerTurns === 1;
            }

            // History navigation methods
            getViewedTurn() {
                if (this.isHistoryMode) {
                    return this.racks[this.viewingRack].turns[this.viewingTurn];
                }
                return this.getTurn();
            }

            getViewingPosition() {
                return this.isHistoryMode
                    ? { rack: this.viewingRack, turn: this.viewingTurn }
                    : { rack: this.currentRack, turn: this.currentTurn };
            }

            navigatePrevious() {
                const current = this.getViewingPosition();

                if (current.turn > 1) {
                    this.viewingRack = current.rack;
                    this.viewingTurn = current.turn - 1;
                    this.isHistoryMode = true;
                } else if (current.rack > 1) {
                    this.viewingRack = current.rack - 1;
                    this.viewingTurn = this.racks[this.viewingRack].turns.length - 1;
                    this.isHistoryMode = true;
                }
                return this.isHistoryMode;
            }

            navigateNext() {
                if (!this.isHistoryMode) return false;

                const current = this.getViewingPosition();
                const turnsInCurrentRack = this.racks[current.rack].turns.length - 1;

                if (current.turn < turnsInCurrentRack) {
                    this.viewingTurn = current.turn + 1;
                } else if (current.rack < this.currentRack) {
                    this.viewingRack = current.rack + 1;
                    this.viewingTurn = 1;
                } else {
                    this.exitHistoryMode();
                }

                if (this.viewingRack === this.currentRack && this.viewingTurn === this.currentTurn) {
                    this.exitHistoryMode();
                }

                return this.isHistoryMode;
            }

            exitHistoryMode() {
                this.isHistoryMode = false;
                this.viewingRack = null;
                this.viewingTurn = null;
            }

            canNavigatePrevious() {
                const pos = this.getViewingPosition();
                return !(pos.rack === 1 && pos.turn === 1);
            }

            canNavigateNext() {
                if (!this.isHistoryMode) return false;
                return true;
            }
        }

        class TPAAnnotation {

            constructor() {
                this.totalPotted = null;
                this.breakPotted = null;
                this.missErrors = null;// can be 0, 1, 2
                this.kick = null;
                this.pocketed = null;
                this.safety = null;
                this.push = null;
                this.safeX = null;
                this.noHit = null;
                this.kickSequence = [];
            }

            reset() {
                this.totalPotted = null;
                this.breakPotted = null;
                this.missErrors = null;
                this.kick = null;
                this.pocketed = null;
                this.safety = null;
                this.push = null;
                this.safeX = null;
                this.noHit = null;
                this.kickSequence = [];
            }

            ballsAnnotated() {
                return this.totalPotted !== null;
            }


            mainNote() {
                if (this.kick) {
                    return 'K';
                } else if (this.safety) {
                    if (this.safeX) {
                        return 'S<sup>x</sup>';
                    } else if (this.push) {
                        return 'S<sup>p</sup>';
                    } else {
                        return 'S';
                    }
                } else if (this.missErrors == 2) {
                    return 'M<sup>n</sup>';
                } else if (this.missErrors == 1) {
                    return 'M';
                }
                return '';
            }

            secondaryNote() {
                if (this.noHit) {
                    return 'N';
                } else if (this.pocketed) {
                    return 'P';
                }
                return '';
            }

            hasKickIn() {
                return this.kickSequence.length > 0;
            }
        }

        class KickIn {
            constructor(player, isFirst) {
                this.player = player;
                this.isFirst = isFirst;
            }
        }
        
        class Turn {
            constructor(player, breakTurn, ballsRemaining) {
                /* breakTurn is a boolean, ballsRemaining is an integer, tpaAnnotation is a TPAAnnotation object */
                this.player = player;
                this.breakTurn = breakTurn;
                this.ballsRemaining = ballsRemaining;
                this.tpaAnnotation = new TPAAnnotation();
                this.pushed = false;
                this.winningTurn = false;
                this.previousTurn = null;
                this.score = null;
                this.consecutiveErrors = 0;
            } 

            showButtons() {
                // Returns the buttons to be displayed
                const buttonIDs = [];
                /* There are 3 phases:
                1) Annotate the balls. If the balls are not annotated (breakPotted === null), show all buttons from 0 to ballsRemaining.
                    1.a) If it's a break (this.breakshot), there are two phases of ball annotation.
                        1.a.1) Annotate the balls potted on the break. (breakPotted === null), show all buttons from 0 to ballsRemaining.
                        1.a.2) Annotate the balls potted on the turn. (breakPotted != null and totalPotted === null), show only buttons 0 and from breakPotted to ballsRemaining. Zero if the cue ball is pocketed.
                2) Main annotation.
                3) Secondary annotation.
                */
                if (this.isWinning() || (this.tpaAnnotation.push)) {
                    if (this.isWinning() && this.previousTurn != null && (this.previousTurn.tpaAnnotation.safeX || this.previousTurn.tpaAnnotation.push || this.previousTurn.tpaAnnotation.safety) && this.tpaAnnotation.kickSequence.length === 0) {
                        buttonIDs.push('buttonK-in');
                    }           
                    return buttonIDs;
                }
                if (!this.tpaAnnotation.ballsAnnotated()) {
                    if (!this.breakTurn || this.tpaAnnotation.breakPotted === null) {
                        for (let i = 0; i <= this.ballsRemaining; i++) {
                            buttonIDs.push(`button${i}`);
                        }
                    } else {
                        buttonIDs.push('button0');
                        for (let i = match.gameType == 8 ? 0 : this.tpaAnnotation.breakPotted; i <= this.ballsRemaining; i++) {
                            buttonIDs.push(`button${i}`);
                        }
                    } 
                } else if (!this.tpaAnnotation.noHit && !this.tpaAnnotation.pocketed) {
                    if (this.breakTurn && this.tpaAnnotation.totalPotted === 0) {//special case where the break shot didn't pocket anything
                        buttonIDs.push('buttonN');
                        buttonIDs.push('buttonP');
                    } else if (!this.tpaAnnotation.safety && !this.tpaAnnotation.missErrors && !this.tpaAnnotation.kick) {
                        if (this.tpaAnnotation.breakPotted <= this.tpaAnnotation.totalPotted && this.tpaAnnotation.totalPotted > 0) {
                            buttonIDs.push('buttonG');
                            if (this.previousTurn != null && (this.previousTurn.tpaAnnotation.safeX || this.previousTurn.tpaAnnotation.push || this.previousTurn.tpaAnnotation.safety) && this.tpaAnnotation.kickSequence.length === 0) {
                                buttonIDs.push('buttonK-in');
                            }                            
                        }
                        buttonIDs.push('buttonM');
                        buttonIDs.push('buttonK');
                        buttonIDs.push('buttonS');
                        buttonIDs.push('buttonP');
                        buttonIDs.push('buttonN');
                    } else {
                        buttonIDs.push('buttonN');
                        buttonIDs.push('buttonP');
                        if (this.tpaAnnotation.safety){
                            if (this.isBreakShot() || (this.isPushed() && this.tpaAnnotation.totalPotted === 0) || (this.previousTurn != null && this.previousTurn.isBreak() && this.previousTurn.tpaAnnotation.totalPotted === 0 && this.tpaAnnotation.totalPotted === 0)) {//the push is legal on the first shot, so in three cases: 1) break with breakPotted === totalPotted, 2) push turn before pocketing any balls (totalPotted === 0), 3) previous turn was a break with totalPotted === 0 
                                buttonIDs.push('buttonp');
                            }
                            if (this.tpaAnnotation.totalPotted > 0) {
                                buttonIDs.push('buttonx');
                            }
                        } else if (this.tpaAnnotation.missErrors === 1) {
                            buttonIDs.push('buttonN');
                            buttonIDs.push('buttonP');
                            buttonIDs.push('buttonn');
                        }
                    }
                }
                return buttonIDs;
            }

            isBreak() {
                return this.breakTurn;
            }

            isBreakShot() {
                return this.isBreak() && this.tpaAnnotation.totalPotted === this.tpaAnnotation.breakPotted;
            }

            push() {
                this.pushed = true;
            }

            isPushed() {
                return this.pushed;
            }

            setWinningTurn() {
                this.winningTurn = true;
            }

            isWinning() {
                return this.winningTurn = this.winningTurn || this.ballsRemaining === 0 || this.ballsRemaining == this.tpaAnnotation.totalPotted;
            }

            hasBeenPlayed() {
                return this.tpaAnnotation.ballsAnnotated();
            }

        }

        function updateButtons(turn) {
            const buttonIDs = [];
            const buttonToShow = turn.showButtons();
            // add the ids of the buttons that are inside the scoreButtons div
            // get all the button children of scoreButtons
            const buttons = document.getElementById('scoreButtons').querySelectorAll('button');
            // for each button, add the id to the buttonIDs array
            buttons.forEach(button => buttonIDs.push(button.id));

            // Numeric button IDs (0-9)
            const numericButtonIDs = ['button0', 'button1', 'button2', 'button3', 'button4', 'button5', 'button6', 'button7', 'button8', 'button9'];

            // Check if ANY numeric button should be visible
            const anyNumericVisible = numericButtonIDs.some(id => buttonToShow.includes(id));

            buttonIDs.forEach(buttonID => {
                const btn = document.getElementById(buttonID);
                const isNumeric = numericButtonIDs.includes(buttonID);
                const shouldShow = buttonToShow.includes(buttonID);

                if (isNumeric) {
                    if (anyNumericVisible) {
                        // Some numeric buttons visible: use visibility to maintain layout
                        btn.style.display = '';
                        btn.style.visibility = shouldShow ? 'visible' : 'hidden';
                    } else {
                        // No numeric buttons visible: collapse the space
                        btn.style.display = 'none';
                        btn.style.visibility = '';
                    }
                } else {
                    // Non-numeric buttons: use display
                    btn.style.display = shouldShow ? '' : 'none';
                    btn.style.visibility = '';
                }
            });

            updateSwitchPlayerStatus();
            document.getElementById('endMatch').classList.remove('d-flex');
        }

        function updateLabels(turn, skipReset = false) {
            const playerLabel = turn.player === 1 ? 'whiteLabel1' : 'whiteLabel2';
            const grayLabel = turn.player === 1 ? 'grayLabel1' : 'grayLabel2';
            const circleEl = document.getElementById(turn.player === 1 ? 'circle1' : 'circle2');

            // Use class for winning turn circle (for new UI)
            if (turn.isWinning()) {
                circleEl.classList.add('winning');
                circleEl.style.border = "2px solid black";
            } else {
                circleEl.classList.remove('winning');
                circleEl.style.border = "none";
            }

            if (turn.player === 1 && !skipReset) {//reset of both players' labels
                document.getElementById('whiteLabel2').textContent = '';
                document.getElementById('grayLabel2').textContent = '';
                document.getElementById('circle2').classList.remove('winning');
                document.getElementById('circle2').style.border = "none";
                document.getElementById('kicks').textContent = '';
                document.getElementById('kicks1').innerHTML = '';
                document.getElementById('kicks2').innerHTML = '';
            }

            let whiteLabelText = '';
            if (turn.tpaAnnotation.breakPotted) {//if breakPotted is defined and not null
                whiteLabelText += `<sup>${turn.tpaAnnotation.breakPotted}</sup>`;
            }
            whiteLabelText += `${turn.tpaAnnotation.totalPotted !== null ? (turn.tpaAnnotation.totalPotted >= 0 ? turn.tpaAnnotation.totalPotted : '') : ''}`;
            whiteLabelText += ` ${turn.tpaAnnotation.mainNote()}`;

            document.getElementById(playerLabel).innerHTML = whiteLabelText;

            document.getElementById(grayLabel).textContent = turn.tpaAnnotation.secondaryNote();

            // Update kicks display - put in player-specific row
            const kicksEl = document.getElementById(`kicks${turn.player}`);
            kicksEl.innerHTML = kickSequence(turn.tpaAnnotation.kickSequence);

            // Also update previous turn's kicks for the other player
            if (turn.previousTurn && turn.previousTurn.tpaAnnotation.kickSequence.length > 0) {
                const otherKicksEl = document.getElementById(`kicks${turn.previousTurn.player}`);
                otherKicksEl.innerHTML = kickSequence(turn.previousTurn.tpaAnnotation.kickSequence);
            }

            // Keep legacy kicks div updated for compatibility
            if (turn.player === 1) {
                document.getElementById('kicks').innerHTML = kickSequence(turn.tpaAnnotation.kickSequence);
            } else {
                if (turn.previousTurn) {
                    document.getElementById('kicks').innerHTML = kickSequence(turn.previousTurn.tpaAnnotation.kickSequence);
                }
                document.getElementById('kicks').innerHTML += kickSequence(turn.tpaAnnotation.kickSequence);
            }

            updateFoulIndicators();
        }

        function setPlayerLabel(playerNum, name) {
            const label = document.getElementById(`player${playerNum}Label`);
            // Clear existing content
            label.textContent = '';
            // Add name as text node
            label.appendChild(document.createTextNode(name));
            // Add foul indicator span
            const span = document.createElement('span');
            span.id = `foulIndicator${playerNum}`;
            span.className = 'foul-indicator';
            label.appendChild(span);
        }

        function updateFoulIndicators() {
            if (!match) return;

            // Get the last completed turn for each player to check their foul count
            const currentTurn = match.getTurn();
            let player1Fouls = 0;
            let player2Fouls = 0;
            let player1Found = false;
            let player2Found = false;

            // Find the most recent completed turn for each player
            let turn = currentTurn;
            while (turn && (!player1Found || !player2Found)) {
                if (turn.tpaAnnotation.totalPotted !== null) { // completed turn
                    if (turn.player === 1 && !player1Found) {
                        player1Fouls = turn.consecutiveErrors;
                        player1Found = true;
                    } else if (turn.player === 2 && !player2Found) {
                        player2Fouls = turn.consecutiveErrors;
                        player2Found = true;
                    }
                }
                turn = turn.previousTurn;
            }

            // Update indicators (show only for 1 or 2 fouls, 3+ triggers auto-win)
            const indicator1 = document.getElementById('foulIndicator1');
            const indicator2 = document.getElementById('foulIndicator2');

            if (indicator1) {
                indicator1.textContent = player1Fouls >= 1 && player1Fouls <= 2 ? `F${player1Fouls}` : '';
            }
            if (indicator2) {
                indicator2.textContent = player2Fouls >= 1 && player2Fouls <= 2 ? `F${player2Fouls}` : '';
            }
        }

        // ==========================================
        // IndexedDB Database Manager
        // ==========================================

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0;
                var v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        class TPADatabase {
            constructor() {
                this.db = null;
                this.dbName = 'TPAScorekeeper';
                this.dbVersion = 1;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;

                        if (!db.objectStoreNames.contains('matches')) {
                            const matchStore = db.createObjectStore('matches', { keyPath: 'id' });
                            matchStore.createIndex('date', 'date', { unique: false });
                            matchStore.createIndex('gameType', 'gameType', { unique: false });
                            matchStore.createIndex('syncedToCloud', 'syncedToCloud', { unique: false });
                        }

                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                        }
                    };
                });
            }

            async saveMatch(matchRecord) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['matches'], 'readwrite');
                    const store = transaction.objectStore('matches');
                    const request = store.put(matchRecord);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getMatch(id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['matches'], 'readonly');
                    const store = transaction.objectStore('matches');
                    const request = store.get(id);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getAllMatches(options = {}) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['matches'], 'readonly');
                    const store = transaction.objectStore('matches');
                    const request = store.getAll();

                    request.onsuccess = () => {
                        let matches = request.result || [];

                        if (options.player) {
                            const playerLower = options.player.toLowerCase();
                            matches = matches.filter(m =>
                                m.players[0].name.toLowerCase().includes(playerLower) ||
                                m.players[1].name.toLowerCase().includes(playerLower)
                            );
                        }

                        if (options.gameType) {
                            matches = matches.filter(m => m.gameType === parseInt(options.gameType));
                        }

                        matches.sort((a, b) => new Date(b.date) - new Date(a.date));
                        resolve(matches);
                    };
                    request.onerror = () => reject(request.error);
                });
            }

            async deleteMatch(id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['matches'], 'readwrite');
                    const store = transaction.objectStore('matches');
                    const request = store.delete(id);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async getMatchCount() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['matches'], 'readonly');
                    const store = transaction.objectStore('matches');
                    const request = store.count();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getPendingMatches() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['matches'], 'readonly');
                    const store = transaction.objectStore('matches');
                    const index = store.index('syncedToCloud');
                    const request = index.getAll(false);
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            }

            async markAsSynced(id) {
                const match = await this.getMatch(id);
                if (match) {
                    match.syncedToCloud = true;
                    match.updatedAt = Date.now();
                    await this.saveMatch(match);
                }
            }

            async getAllPlayers() {
                const matches = await this.getAllMatches();
                const players = new Set();
                matches.forEach(m => {
                    players.add(m.players[0].name);
                    players.add(m.players[1].name);
                });
                return Array.from(players).sort();
            }

            async getSetting(key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['settings'], 'readonly');
                    const store = transaction.objectStore('settings');
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result?.value);
                    request.onerror = () => reject(request.error);
                });
            }

            async setSetting(key, value) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['settings'], 'readwrite');
                    const store = transaction.objectStore('settings');
                    const request = store.put({ key, value });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async exportAllData() {
                const matches = await this.getAllMatches();
                const settings = await this.getAllSettings();
                return { matches, settings, exportDate: new Date().toISOString(), version: 1 };
            }

            async getAllSettings() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['settings'], 'readonly');
                    const store = transaction.objectStore('settings');
                    const request = store.getAll();
                    request.onsuccess = () => {
                        const settings = {};
                        (request.result || []).forEach(s => settings[s.key] = s.value);
                        resolve(settings);
                    };
                    request.onerror = () => reject(request.error);
                });
            }

            async importData(data) {
                const imported = { matches: 0, skipped: 0 };

                if (data.matches && Array.isArray(data.matches)) {
                    for (const matchRecord of data.matches) {
                        try {
                            const existing = await this.getMatch(matchRecord.id);
                            if (!existing) {
                                await this.saveMatch(matchRecord);
                                imported.matches++;
                            } else {
                                imported.skipped++;
                            }
                        } catch (e) {
                            console.error('Error importing match:', e);
                        }
                    }
                }

                if (data.settings) {
                    for (const [key, value] of Object.entries(data.settings)) {
                        await this.setSetting(key, value);
                    }
                }

                return imported;
            }

            async clearAll() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['matches', 'settings'], 'readwrite');
                    transaction.objectStore('matches').clear();
                    transaction.objectStore('settings').clear();
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(transaction.error);
                });
            }
        }

        let tpaDB = null;

        // ==========================================
        // View Navigation
        // ==========================================

        const VIEWS = ['playerForm', 'main', 'results', 'historyView', 'matchDetailView', 'statsView', 'settingsView'];

        function showView(viewId) {
            VIEWS.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.style.display = id === viewId ? 'block' : 'none';
                }
            });
            if (viewId !== 'main') {
                document.getElementById('dateTitle').style.display = 'none';
                document.getElementById('gameTypeTitle').style.display = 'none';
                document.getElementById('endMatch').classList.remove('d-flex');
            }
        }

        function showPlayerForm() {
            showView('playerForm');
            document.getElementById('playerForm').classList.add('d-flex');
        }

        async function showHistoryView() {
            showView('historyView');
            await populatePlayerFilter();
            await loadMatchHistory();
        }

        function showMatchDetail(matchId) {
            currentViewingMatchId = matchId;
            showView('matchDetailView');
            loadMatchDetail(matchId);
        }

        async function showStatsView() {
            showView('statsView');
            await populateStatsPlayerSelect();
            document.getElementById('statsContent').style.display = 'none';
            document.getElementById('statsEmpty').style.display = 'block';
        }

        async function showSettingsView() {
            showView('settingsView');
            await loadSettings();
        }

        // ==========================================
        // History View Functions
        // ==========================================

        let currentHistoryPage = 1;
        const MATCHES_PER_PAGE = 10;
        let currentViewingMatchId = null;

        async function populatePlayerFilter() {
            const players = await tpaDB.getAllPlayers();
            const select = document.getElementById('historyFilterPlayer');
            select.textContent = '';
            const defaultOpt = document.createElement('option');
            defaultOpt.value = '';
            defaultOpt.textContent = 'All Players';
            select.appendChild(defaultOpt);
            players.forEach(p => {
                const option = document.createElement('option');
                option.value = p;
                option.textContent = p;
                select.appendChild(option);
            });
        }

        async function loadMatchHistory(page = 1) {
            currentHistoryPage = page;
            const playerFilter = document.getElementById('historyFilterPlayer').value;
            const gameFilter = document.getElementById('historyFilterGame').value;

            const allMatches = await tpaDB.getAllMatches({
                player: playerFilter,
                gameType: gameFilter
            });

            const totalPages = Math.ceil(allMatches.length / MATCHES_PER_PAGE);
            const startIndex = (page - 1) * MATCHES_PER_PAGE;
            const matches = allMatches.slice(startIndex, startIndex + MATCHES_PER_PAGE);

            const listEl = document.getElementById('historyList');
            listEl.textContent = '';

            if (matches.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'text-center text-muted py-4';
                emptyDiv.textContent = 'No matches found';
                listEl.appendChild(emptyDiv);
                document.getElementById('historyPagination').style.display = 'none';
                return;
            }

            matches.forEach(m => {
                const p1Won = m.finalScore.player1.racksWon > m.finalScore.player2.racksWon;
                const card = document.createElement('a');
                card.href = '#';
                card.className = 'list-group-item list-group-item-action match-card';
                card.onclick = function(e) { e.preventDefault(); showMatchDetail(m.id); };

                const topRow = document.createElement('div');
                topRow.className = 'd-flex justify-content-between align-items-center';

                const playersDiv = document.createElement('div');
                const p1Span = document.createElement('span');
                p1Span.className = p1Won ? 'winner' : 'loser';
                p1Span.textContent = m.players[0].name;
                const scoreSpan = document.createElement('span');
                scoreSpan.className = 'match-score';
                scoreSpan.textContent = ' ' + m.finalScore.player1.racksWon + ' - ' + m.finalScore.player2.racksWon + ' ';
                const p2Span = document.createElement('span');
                p2Span.className = p1Won ? 'loser' : 'winner';
                p2Span.textContent = m.players[1].name;
                playersDiv.appendChild(p1Span);
                playersDiv.appendChild(scoreSpan);
                playersDiv.appendChild(p2Span);

                const badge = document.createElement('span');
                badge.className = 'badge bg-secondary';
                badge.textContent = m.gameType + '-ball';

                topRow.appendChild(playersDiv);
                topRow.appendChild(badge);

                const dateDiv = document.createElement('div');
                dateDiv.className = 'match-date';
                dateDiv.textContent = m.date;

                const tpaDiv = document.createElement('div');
                tpaDiv.className = 'match-tpa';
                tpaDiv.textContent = 'TPA: ' + m.finalScore.player1.tpaScore + ' / ' + m.finalScore.player2.tpaScore;

                card.appendChild(topRow);
                card.appendChild(dateDiv);
                card.appendChild(tpaDiv);
                listEl.appendChild(card);
            });

            const paginationEl = document.getElementById('historyPagination');
            if (totalPages > 1) {
                paginationEl.style.display = 'block';
                document.getElementById('pageInfo').textContent = 'Page ' + page + ' of ' + totalPages;
                document.getElementById('prevPageItem').classList.toggle('disabled', page <= 1);
                document.getElementById('nextPageItem').classList.toggle('disabled', page >= totalPages);
            } else {
                paginationEl.style.display = 'none';
            }
        }

        // ==========================================
        // Match Detail Functions
        // ==========================================

        async function loadMatchDetail(matchId) {
            const matchRecord = await tpaDB.getMatch(matchId);
            if (!matchRecord) {
                alert('Match not found');
                showHistoryView();
                return;
            }

            document.getElementById('detailPlayer1Name').textContent = matchRecord.players[0].name;
            document.getElementById('detailPlayer2Name').textContent = matchRecord.players[1].name;
            document.getElementById('detailPlayer1Racks').textContent = matchRecord.finalScore.player1.racksWon;
            document.getElementById('detailPlayer2Racks').textContent = matchRecord.finalScore.player2.racksWon;
            document.getElementById('detailPlayer1TPA').textContent = 'TPA: ' + matchRecord.finalScore.player1.tpaScore;
            document.getElementById('detailPlayer2TPA').textContent = 'TPA: ' + matchRecord.finalScore.player2.tpaScore;
            document.getElementById('detailMatchDate').textContent = matchRecord.date;
            document.getElementById('detailGameType').textContent = matchRecord.gameType + '-ball';

            const p1Won = matchRecord.finalScore.player1.racksWon > matchRecord.finalScore.player2.racksWon;
            document.getElementById('detailPlayer1Name').className = p1Won ? 'winner' : '';
            document.getElementById('detailPlayer2Name').className = p1Won ? '' : 'winner';

            // htmlTable is trusted content generated by the app itself
            const tableContainer = document.getElementById('matchDetailTable');
            tableContainer.textContent = '';
            const wrapper = document.createElement('div');
            wrapper.innerHTML = matchRecord.htmlTable;
            tableContainer.appendChild(wrapper);
        }

        async function deleteCurrentMatch() {
            if (!currentViewingMatchId) return;

            if (!confirm('Are you sure you want to delete this match? This cannot be undone.')) {
                return;
            }

            await tpaDB.deleteMatch(currentViewingMatchId);
            currentViewingMatchId = null;
            showHistoryView();
        }

        // ==========================================
        // Statistics Functions
        // ==========================================

        let tpaTrendChart = null;
        let errorTrendChart = null;
        let currentErrorHistory = []; // Store error history for checkbox filtering

        async function populateStatsPlayerSelect() {
            const players = await tpaDB.getAllPlayers();
            const select = document.getElementById('statsPlayerSelect');
            select.textContent = '';
            const defaultOpt = document.createElement('option');
            defaultOpt.value = '';
            defaultOpt.textContent = 'Select Player';
            select.appendChild(defaultOpt);
            players.forEach(p => {
                const option = document.createElement('option');
                option.value = p;
                option.textContent = p;
                select.appendChild(option);
            });
        }

        function onTimeRangeChange() {
            const timeRange = document.getElementById('statsTimeRange').value;
            document.getElementById('customDateRange').style.display = timeRange === 'custom' ? 'flex' : 'none';
            loadPlayerStats();
        }

        function getDateFilters() {
            const timeRange = document.getElementById('statsTimeRange').value;
            const now = new Date();
            let dateFrom = null;
            let dateTo = null;

            if (timeRange === '1m') {
                dateFrom = new Date(now.getFullYear(), now.getMonth() - 1, now.getDate());
            } else if (timeRange === '3m') {
                dateFrom = new Date(now.getFullYear(), now.getMonth() - 3, now.getDate());
            } else if (timeRange === '6m') {
                dateFrom = new Date(now.getFullYear(), now.getMonth() - 6, now.getDate());
            } else if (timeRange === '1y') {
                dateFrom = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate());
            } else if (timeRange === 'custom') {
                const fromVal = document.getElementById('statsDateFrom').value;
                const toVal = document.getElementById('statsDateTo').value;
                if (fromVal) dateFrom = new Date(fromVal);
                if (toVal) dateTo = new Date(toVal);
            }

            return { dateFrom, dateTo };
        }

        async function loadPlayerStats() {
            const playerName = document.getElementById('statsPlayerSelect').value;
            const gameFilter = document.getElementById('statsGameFilter').value;

            if (!playerName) {
                document.getElementById('statsContent').style.display = 'none';
                document.getElementById('statsEmpty').style.display = 'block';
                return;
            }

            document.getElementById('statsContent').style.display = 'block';
            document.getElementById('statsEmpty').style.display = 'none';

            const { dateFrom, dateTo } = getDateFilters();
            const minRacks = parseInt(document.getElementById('statsMinRacks').value) || 0;

            const stats = await calculatePlayerStats(playerName, gameFilter, { dateFrom, dateTo, minRacks });

            document.getElementById('statsTpaAvg').textContent = stats.avgTpa;
            document.getElementById('statsWinRate').textContent = stats.winRate + '%';
            document.getElementById('statsMatches').textContent = stats.totalMatches;
            document.getElementById('statsBreakAndRuns').textContent = stats.totalBreakAndRuns;
            document.getElementById('statsRunOuts').textContent = stats.totalRunOuts;
            document.getElementById('statsPerfectRacks').textContent = stats.totalPerfectRacks;

            updateTpaTrendChart(stats.history);
            currentErrorHistory = stats.errorHistory;
            updateErrorTrendChart();
            updateHeadToHead(stats.opponents);
        }

        async function calculatePlayerStats(playerName, gameType, options = {}) {
            let matches = await tpaDB.getAllMatches({ player: playerName, gameType: gameType });
            const normalizedName = playerName.toLowerCase().trim();
            const { dateFrom, dateTo, minRacks } = options;

            // Apply date and rack filters
            matches = matches.filter(m => {
                const matchDate = new Date(m.date);
                if (dateFrom && matchDate < dateFrom) return false;
                if (dateTo && matchDate > dateTo) return false;

                if (minRacks && minRacks > 0) {
                    const totalRacks = m.finalScore.player1.racksWon + m.finalScore.player2.racksWon;
                    if (totalRacks < minRacks) return false;
                }

                return true;
            });

            const stats = {
                totalMatches: 0,
                wins: 0,
                totalTpa: 0,
                totalMissErrors: 0,
                totalBreakErrors: 0,
                totalKickErrors: 0,
                totalSafetyErrors: 0,
                totalPositionErrors: 0,
                totalBreakAndRuns: 0,
                totalRunOuts: 0,
                totalPerfectRacks: 0,
                opponents: {},
                history: [],
                errorHistory: []
            };

            matches.forEach(m => {
                const isPlayer1 = m.players[0].name.toLowerCase().trim() === normalizedName;
                const playerScore = isPlayer1 ? m.finalScore.player1 : m.finalScore.player2;
                const opponentScore = isPlayer1 ? m.finalScore.player2 : m.finalScore.player1;
                const opponentName = isPlayer1 ? m.players[1].name : m.players[0].name;

                stats.totalMatches++;
                stats.totalTpa += playerScore.tpaScore;
                stats.totalMissErrors += playerScore.missErrors;
                stats.totalBreakErrors += playerScore.breakErrors;
                stats.totalKickErrors += playerScore.kickErrors;
                stats.totalSafetyErrors += playerScore.safetyErrors;
                stats.totalPositionErrors += playerScore.positionError;
                // Achievements (with fallback for old records)
                stats.totalBreakAndRuns += playerScore.breakAndRuns || 0;
                stats.totalRunOuts += playerScore.runOuts || 0;
                stats.totalPerfectRacks += playerScore.perfectRacks || 0;

                const won = playerScore.racksWon > opponentScore.racksWon;
                if (won) stats.wins++;

                const oppKey = opponentName.toLowerCase().trim();
                if (!stats.opponents[oppKey]) {
                    stats.opponents[oppKey] = {
                        displayName: opponentName,
                        matches: 0,
                        wins: 0,
                        losses: 0
                    };
                }
                stats.opponents[oppKey].matches++;
                if (won) {
                    stats.opponents[oppKey].wins++;
                } else {
                    stats.opponents[oppKey].losses++;
                }

                stats.history.push({
                    date: m.date,
                    tpaScore: playerScore.tpaScore,
                    won: won
                });

                stats.errorHistory.push({
                    date: m.date,
                    miss: playerScore.missErrors,
                    break: playerScore.breakErrors,
                    kick: playerScore.kickErrors,
                    safety: playerScore.safetyErrors,
                    position: playerScore.positionError
                });
            });

            stats.history.sort((a, b) => new Date(a.date) - new Date(b.date));
            stats.errorHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
            stats.avgTpa = stats.totalMatches > 0 ? Math.round(stats.totalTpa / stats.totalMatches) : 0;
            stats.winRate = stats.totalMatches > 0 ? Math.round(stats.wins / stats.totalMatches * 100) : 0;

            return stats;
        }

        function updateTpaTrendChart(history) {
            const ctx = document.getElementById('tpaTrendChart').getContext('2d');

            if (tpaTrendChart) {
                tpaTrendChart.destroy();
            }

            const labels = history.map(h => h.date.split(' ')[0]);
            const data = history.map(h => h.tpaScore);

            tpaTrendChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'TPA Score',
                        data: data,
                        borderColor: '#0d6efd',
                        backgroundColor: 'rgba(13, 110, 253, 0.1)',
                        fill: true,
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { min: 0, max: 1000 }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }

        function updateErrorTrendChart() {
            const ctx = document.getElementById('errorTrendChart').getContext('2d');

            if (errorTrendChart) {
                errorTrendChart.destroy();
            }

            if (!currentErrorHistory || currentErrorHistory.length === 0) {
                errorTrendChart = null;
                return;
            }

            const labels = currentErrorHistory.map(h => h.date.split(' ')[0]);
            const datasets = [];

            const errorTypes = [
                { key: 'miss', checkId: 'errMiss', label: 'Miss', color: '#dc3545' },
                { key: 'break', checkId: 'errBreak', label: 'Break', color: '#fd7e14' },
                { key: 'kick', checkId: 'errKick', label: 'Kick', color: '#ffc107' },
                { key: 'safety', checkId: 'errSafety', label: 'Safety', color: '#20c997' },
                { key: 'position', checkId: 'errPosition', label: 'Position', color: '#6f42c1' }
            ];

            errorTypes.forEach(errType => {
                const checkbox = document.getElementById(errType.checkId);
                if (checkbox && checkbox.checked) {
                    datasets.push({
                        label: errType.label,
                        data: currentErrorHistory.map(h => h[errType.key]),
                        borderColor: errType.color,
                        backgroundColor: errType.color + '20',
                        fill: false,
                        tension: 0.3
                    });
                }
            });

            errorTrendChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { beginAtZero: true }
                    },
                    plugins: {
                        legend: { position: 'bottom' }
                    }
                }
            });
        }

        function updateHeadToHead(opponents) {
            const listEl = document.getElementById('headToHeadList');
            listEl.textContent = '';
            const opponentEntries = Object.values(opponents).sort((a, b) => b.matches - a.matches);

            if (opponentEntries.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'text-muted';
                emptyDiv.textContent = 'No opponents found';
                listEl.appendChild(emptyDiv);
                return;
            }

            opponentEntries.forEach(opp => {
                const item = document.createElement('div');
                item.className = 'list-group-item d-flex justify-content-between align-items-center';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = opp.displayName;

                const recordSpan = document.createElement('span');
                recordSpan.className = opp.wins > opp.losses ? 'text-success' : (opp.wins < opp.losses ? 'text-danger' : '');
                recordSpan.textContent = opp.wins + 'W - ' + opp.losses + 'L (' + opp.matches + ' matches)';

                item.appendChild(nameSpan);
                item.appendChild(recordSpan);
                listEl.appendChild(item);
            });
        }

        // ==========================================
        // Settings Functions
        // ==========================================

        const GOOGLE_SHEET_URL = 'https://script.google.com/macros/s/AKfycbzn6HJDjup8zqvASM4-cB9zmPcPMi8h-u-iXAXaPDenkr_G9Q2Ap05mrisaWL_Fe8FK4w/exec';

        async function loadSettings() {
            const matchCount = await tpaDB.getMatchCount();
            document.getElementById('matchCount').textContent = matchCount;
            // Load display settings
            const savedSettings = await tpaDB.getSetting('displaySettings');
            if (savedSettings) {
                displaySettings = { ...displaySettings, ...savedSettings };
            }
            // Update checkboxes
            const showBR = document.getElementById('showBR');
            const showRO = document.getElementById('showRO');
            const showPR = document.getElementById('showPR');
            const errorTotal = document.getElementById('errorTotal');
            const errorByType = document.getElementById('errorByType');
            if (showBR) showBR.checked = displaySettings.showBR;
            if (showRO) showRO.checked = displaySettings.showRO;
            if (showPR) showPR.checked = displaySettings.showPR;
            if (errorTotal) errorTotal.checked = displaySettings.errorDisplay === 'total';
            if (errorByType) errorByType.checked = displaySettings.errorDisplay === 'byType';
        }

        async function saveDisplaySettings() {
            displaySettings.showBR = document.getElementById('showBR').checked;
            displaySettings.showRO = document.getElementById('showRO').checked;
            displaySettings.showPR = document.getElementById('showPR').checked;
            displaySettings.errorDisplay = document.getElementById('errorByType').checked ? 'byType' : 'total';
            await tpaDB.setSetting('displaySettings', displaySettings);
            // Update display if match is active
            if (match) {
                updatePlayerDisplay();
            }
        }

        function getGoogleSheetUrl() {
            return GOOGLE_SHEET_URL;
        }

        function isAutoSyncEnabled() {
            return true; // Always sync to Google Sheets
        }

        async function exportData() {
            const data = await tpaDB.exportAllData();
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'tpa-matches-' + new Date().toISOString().split('T')[0] + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function importData() {
            const fileInput = document.getElementById('importFile');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file to import');
                return;
            }

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (!data.matches || !Array.isArray(data.matches)) {
                    alert('Invalid file format');
                    return;
                }

                const result = await tpaDB.importData(data);
                alert('Imported ' + result.matches + ' matches. ' + result.skipped + ' duplicates skipped.');

                fileInput.value = '';
                await loadSettings();
            } catch (e) {
                alert('Error importing file: ' + e.message);
            }
        }

        async function clearAllData() {
            if (!confirm('This will permanently delete ALL local match data. Are you sure?')) {
                return;
            }
            if (!confirm('This action cannot be undone. Click OK to proceed.')) {
                return;
            }

            await tpaDB.clearAll();
            alert('All local data has been cleared');
            await loadSettings();
        }
    </script>

    <script>
        let match = null;

        function startMatch() {
            // Read names directly from inputs (not cookies) to avoid timing issues
            const player1Name = document.getElementById('player1').value || 'Player 1';
            const player2Name = document.getElementById('player2').value || 'Player 2';
            saveNames(); // Save to cookies for next time
            match = new Match(player1Name, player2Name, document.querySelector('input[name="gameType"]:checked').value);

            // Hide all views first
            VIEWS.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });
            document.getElementById('playerForm').classList.remove('d-flex');

            // Show match interface
            document.getElementById('dateTitle').style.display = 'block';
            document.getElementById('gameTypeTitle').style.display = 'block';
            document.getElementById('main').style.display = 'block';

            document.getElementById('dateTitle').textContent = match.startDate;
            document.getElementById('gameTypeTitle').textContent = gameTypeName(match.gameType);
            setPlayerLabel(1, match.players[0].name);
            setPlayerLabel(2, match.players[1].name);

            const buttons = document.getElementById('scoreButtons').querySelectorAll('button.btn-square');
            // for each button, add match's annotate function as a listener
            buttons.forEach(button => button.addEventListener('click', match.annotate.bind(match)));
            // add a listener to kick-in button that adds the kick sequence on click
            document.getElementById('buttonK-in').addEventListener('click', function() {
                match.getTurn().tpaAnnotation.kickSequence.push(new KickIn(match.currentPlayer, true));
                updateLabels(match.getTurn());
                updateButtons(match.getTurn());
                saveMatchState();
            });

            updateLabels(match.getTurn());
            updateButtons(match.getTurn());
            updatePlayerDisplay();
            initSwipeNavigation();
            saveMatchState();
        }

        function resumeMatch(restoredMatch) {
            match = restoredMatch;

            // Hide all views first
            VIEWS.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });
            document.getElementById('playerForm').classList.remove('d-flex');

            // Show match interface
            document.getElementById('dateTitle').style.display = 'block';
            document.getElementById('gameTypeTitle').style.display = 'block';
            document.getElementById('main').style.display = 'block';

            document.getElementById('dateTitle').textContent = match.startDate;
            document.getElementById('gameTypeTitle').textContent = gameTypeName(match.gameType);
            setPlayerLabel(1, match.players[0].name);
            setPlayerLabel(2, match.players[1].name);

            const buttons = document.getElementById('scoreButtons').querySelectorAll('button.btn-square');
            buttons.forEach(button => button.addEventListener('click', match.annotate.bind(match)));
            document.getElementById('buttonK-in').addEventListener('click', function() {
                match.getTurn().tpaAnnotation.kickSequence.push(new KickIn(match.currentPlayer, true));
                updateLabels(match.getTurn());
                updateButtons(match.getTurn());
                saveMatchState();
            });

            // Find the last turn of each player across all racks
            let lastPlayer1Turn = null;
            let lastPlayer1Position = { rack: 0, turn: 0 };
            let lastPlayer2Turn = null;
            let lastPlayer2Position = { rack: 0, turn: 0 };

            // Search backwards through all racks to find last turn of each player
            for (let r = match.currentRack; r >= 1; r--) {
                const maxTurn = (r === match.currentRack) ? match.currentTurn : match.racks[r].turns.length - 1;
                for (let t = maxTurn; t >= 1; t--) {
                    const turn = match.racks[r].turns[t];
                    if (!turn) continue;

                    if (turn.player === 1 && !lastPlayer1Turn) {
                        lastPlayer1Turn = turn;
                        lastPlayer1Position = { rack: r, turn: t };
                    }
                    if (turn.player === 2 && !lastPlayer2Turn) {
                        lastPlayer2Turn = turn;
                        lastPlayer2Position = { rack: r, turn: t };
                    }
                    if (lastPlayer1Turn && lastPlayer2Turn) break;
                }
                if (lastPlayer1Turn && lastPlayer2Turn) break;
            }

            // Determine if player 2's turn should be shown
            // Player 2 gets reset when player 1 plays, so only show player 2 if their
            // last turn is AFTER player 1's last turn
            let showPlayer2 = false;
            if (lastPlayer2Turn) {
                if (!lastPlayer1Turn) {
                    showPlayer2 = true;
                } else {
                    // Player 2 shown only if their turn is after player 1's
                    showPlayer2 = (lastPlayer2Position.rack > lastPlayer1Position.rack) ||
                                  (lastPlayer2Position.rack === lastPlayer1Position.rack &&
                                   lastPlayer2Position.turn > lastPlayer1Position.turn);
                }
            }

            // Show player 1's turn (resets player 2), then player 2's turn if valid
            if (lastPlayer1Turn) {
                updateLabels(lastPlayer1Turn);
            }
            if (showPlayer2) {
                updateLabels(lastPlayer2Turn);
            }
            updateButtons(match.getTurn());
            const scoreEl = document.getElementById('score');
            scoreEl.textContent = '';
            scoreEl.insertAdjacentHTML('beforeend', scoreToString(match.score));
            updatePlayerDisplay();
            initSwipeNavigation();
            updateHistoryNavButtons();

            // Restore history mode if it was active
            if (match.isHistoryMode) {
                enterViewMode();
            }

            // Show endMatch button if current turn is a break (ready for new rack)
            if (match.getTurn().isBreak() && !match.getTurn().hasBeenPlayed()) {
                document.getElementById('endMatch').classList.add('d-flex');
            }
        }

        // Swipe navigation
        function initSwipeNavigation() {
            const mainDiv = document.getElementById('main');
            let startX = 0;
            let startY = 0;
            const SWIPE_THRESHOLD = 50;
            const SWIPE_RESTRAINT = 100;

            // Touch events for mobile
            mainDiv.addEventListener('touchstart', function(e) {
                startX = e.changedTouches[0].screenX;
                startY = e.changedTouches[0].screenY;
            }, { passive: true });

            mainDiv.addEventListener('touchend', function(e) {
                const endX = e.changedTouches[0].screenX;
                const endY = e.changedTouches[0].screenY;
                handleSwipeGesture(endX - startX, endY - startY);
            }, { passive: true });

            // Mouse events for desktop testing
            let mouseDown = false;
            let dragStartX = 0;
            let dragStartY = 0;

            mainDiv.addEventListener('mousedown', function(e) {
                mouseDown = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
            });

            document.addEventListener('mousemove', function(e) {
                if (mouseDown) {
                    e.preventDefault(); // Prevent text selection while dragging
                }
            });

            document.addEventListener('mouseup', function(e) {
                if (mouseDown) {
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    mouseDown = false;

                    if (Math.abs(deltaX) > SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_RESTRAINT) {
                        handleSwipeGesture(deltaX, deltaY);
                    }
                }
            });

            function handleSwipeGesture(deltaX, deltaY) {
                if (Math.abs(deltaX) > SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_RESTRAINT) {
                    if (deltaX < 0) {
                        handleSwipeLeft();
                    } else {
                        handleSwipeRight();
                    }
                }
            }
        }

        function handleSwipeLeft() {
            navigateBack();
        }

        function handleSwipeRight() {
            navigateForward();
        }

        function navigateBack() {
            if (match.navigatePrevious()) {
                enterViewMode();
                updateHistoryNavButtons();
            }
        }

        function navigateForward() {
            if (match.isHistoryMode) {
                match.navigateNext();
                if (!match.isHistoryMode) {
                    exitViewMode();
                } else {
                    updateViewModeDisplay();
                }
                updateHistoryNavButtons();
            }
        }

        function updateHistoryNavButtons() {
            const historyNav = document.getElementById('historyNav');
            const btnBack = document.getElementById('btnHistoryBack');
            const btnForward = document.getElementById('btnHistoryForward');

            // Show nav buttons if there's any history (more than just the current turn)
            const hasHistory = match.currentRack > 1 || match.currentTurn > 1;
            historyNav.style.display = hasHistory ? 'flex' : 'none';

            // Update button states
            btnBack.disabled = !match.canNavigatePrevious();
            btnForward.disabled = !match.isHistoryMode;
        }

        // View mode functions
        function enterViewMode() {
            document.body.classList.add('history-mode');
            updateViewModeDisplay();
        }

        function exitViewMode() {
            document.body.classList.remove('history-mode');
            document.body.classList.remove('edit-mode');
            updateLabels(match.getTurn());
            updateButtons(match.getTurn());
            document.getElementById('score').textContent = '';
            document.getElementById('score').insertAdjacentHTML('beforeend', scoreToString(match.score));
            updateHistoryNavButtons();

            // Show endMatch button if current turn is a break and not yet played
            if (match.getTurn().isBreak() && !match.getTurn().hasBeenPlayed()) {
                document.getElementById('endMatch').classList.add('d-flex');
            } else {
                document.getElementById('endMatch').classList.remove('d-flex');
            }
        }

        function updateViewModeDisplay() {
            const viewedTurn = match.getViewedTurn();
            const pos = match.getViewingPosition();

            document.getElementById('historyRack').textContent = pos.rack;
            document.getElementById('historyTurn').textContent = pos.turn;

            displayHistoricalTurn(viewedTurn);
        }

        function displayHistoricalTurn(turn) {
            // Clear both player displays - use CSS classes, not inline styles
            document.getElementById('whiteLabel1').textContent = '';
            document.getElementById('whiteLabel2').textContent = '';
            document.getElementById('grayLabel1').textContent = '';
            document.getElementById('grayLabel2').textContent = '';
            // Remove inline border styles so CSS rules can take effect
            document.getElementById('circle1').style.removeProperty('border');
            document.getElementById('circle2').style.removeProperty('border');
            document.getElementById('circle1').classList.remove('winning');
            document.getElementById('circle2').classList.remove('winning');
            document.getElementById('kicks').textContent = '';
            document.getElementById('kicks1').innerHTML = '';
            document.getElementById('kicks2').innerHTML = '';

            // Display the viewed turn
            const playerLabel = turn.player === 1 ? 'whiteLabel1' : 'whiteLabel2';
            const grayLabel = turn.player === 1 ? 'grayLabel1' : 'grayLabel2';
            const circle = turn.player === 1 ? 'circle1' : 'circle2';

            let whiteLabelText = '';
            if (turn.tpaAnnotation.breakPotted) {
                whiteLabelText += '<sup>' + turn.tpaAnnotation.breakPotted + '</sup>';
            }
            whiteLabelText += (turn.tpaAnnotation.totalPotted !== null ? turn.tpaAnnotation.totalPotted : '');
            whiteLabelText += ' ' + turn.tpaAnnotation.mainNote();

            const labelEl = document.getElementById(playerLabel);
            labelEl.textContent = '';
            labelEl.insertAdjacentHTML('beforeend', whiteLabelText);

            document.getElementById(grayLabel).textContent = turn.tpaAnnotation.secondaryNote();

            // Handle winning turn display - use CSS class only, no inline styles
            const circleEl = document.getElementById(circle);
            if (turn.isWinning()) {
                circleEl.classList.add('winning');
            }
            // CSS rules handle border visibility:
            // .history-mode .annotation-cell { border: none }
            // .history-mode .annotation-cell.winning { border: 2px solid orange, border-radius: 50% }

            // Show kicks in player-specific row
            document.getElementById(`kicks${turn.player}`).innerHTML = kickSequence(turn.tpaAnnotation.kickSequence);

            // Show kicks in legacy element for compatibility
            const kicksEl = document.getElementById('kicks');
            kicksEl.textContent = '';
            kicksEl.insertAdjacentHTML('beforeend', kickSequence(turn.tpaAnnotation.kickSequence));

            // Show historical score
            if (turn.score) {
                const scoreEl = document.getElementById('score');
                scoreEl.textContent = '';
                scoreEl.insertAdjacentHTML('beforeend', turn.score);
            }

            // Update active player indicator to show whose turn this was
            const label1 = document.getElementById('player1Label');
            const label2 = document.getElementById('player2Label');
            if (turn.player === 1) {
                label1.classList.add('active');
                label2.classList.remove('active');
            } else {
                label1.classList.remove('active');
                label2.classList.add('active');
            }
        }

        // Edit mode functions
        let originalTurnSnapshot = null;
        let editingPosition = null;

        function createAnnotationSnapshot(turn) {
            return {
                totalPotted: turn.tpaAnnotation.totalPotted,
                breakPotted: turn.tpaAnnotation.breakPotted,
                missErrors: turn.tpaAnnotation.missErrors,
                kick: turn.tpaAnnotation.kick,
                pocketed: turn.tpaAnnotation.pocketed,
                safety: turn.tpaAnnotation.safety,
                push: turn.tpaAnnotation.push,
                safeX: turn.tpaAnnotation.safeX,
                noHit: turn.tpaAnnotation.noHit,
                kickSequence: turn.tpaAnnotation.kickSequence.slice(),
                winningTurn: turn.winningTurn
            };
        }

        function annotationsEqual(snap1, snap2) {
            return JSON.stringify(snap1) === JSON.stringify(snap2);
        }

        function enterEditMode() {
            if (!match.isHistoryMode) return;

            const pos = match.getViewingPosition();
            const subsequentTurns = countSubsequentTurns(pos);

            const message = 'Modificare Rack ' + pos.rack + ', Turno ' + pos.turn + '?\n\n' +
                'Questo eliminerà ' + subsequentTurns + ' turni successivi.\n\n' +
                'Continuare?';

            if (!confirm(message)) {
                return;
            }

            // Truncate all subsequent turns
            match.racks[pos.rack].turns.length = pos.turn + 1;
            match.racks.length = pos.rack + 1;

            // Set current position to this turn
            match.currentRack = pos.rack;
            match.currentTurn = pos.turn;
            match.isHistoryMode = false;

            // Reset the turn's annotation to allow re-entry
            const turn = match.getTurn();

            // Set the correct player (the one who made this turn)
            match.currentPlayer = turn.player;
            turn.tpaAnnotation.reset();
            turn.winningTurn = false;
            turn.score = null;

            // Recalculate scores up to (but not including) this turn
            recalculateAllScores();

            // Exit history mode and return to normal
            document.body.classList.remove('history-mode');

            updateLabels(turn);
            updateButtons(turn);
            updateHistoryNavButtons();
            updateSwitchPlayerStatus();
            document.getElementById('score').textContent = '';
            document.getElementById('score').insertAdjacentHTML('beforeend', scoreToString(match.score));
            saveMatchState();
        }

        function checkForEditChanges() {
            if (!editingPosition) return;

            const turn = match.getTurn();
            const currentSnapshot = createAnnotationSnapshot(turn);

            if (!annotationsEqual(originalTurnSnapshot, currentSnapshot)) {
                showEditConfirmation();
            }
        }

        function countSubsequentTurns(position) {
            let count = 0;
            count += match.racks[position.rack].turns.length - 1 - position.turn;
            for (let r = position.rack + 1; r < match.racks.length; r++) {
                count += match.racks[r].turns.length - 1;
            }
            return count;
        }

        function showEditConfirmation() {
            const pos = editingPosition;
            const subsequentTurns = countSubsequentTurns(pos);

            const message = 'Stai modificando Rack ' + pos.rack + ', Turno ' + pos.turn + '.\n\n' +
                'Questo eliminerà ' + subsequentTurns + ' turni successivi e ricalcolerà i punteggi.\n\n' +
                'Continuare?';

            if (confirm(message)) {
                applyHistoricalEdit();
            } else {
                revertEdit();
            }
        }

        function revertEdit() {
            const turn = match.getTurn();
            const snap = originalTurnSnapshot;

            turn.tpaAnnotation.totalPotted = snap.totalPotted;
            turn.tpaAnnotation.breakPotted = snap.breakPotted;
            turn.tpaAnnotation.missErrors = snap.missErrors;
            turn.tpaAnnotation.kick = snap.kick;
            turn.tpaAnnotation.pocketed = snap.pocketed;
            turn.tpaAnnotation.safety = snap.safety;
            turn.tpaAnnotation.push = snap.push;
            turn.tpaAnnotation.safeX = snap.safeX;
            turn.tpaAnnotation.noHit = snap.noHit;
            turn.tpaAnnotation.kickSequence = snap.kickSequence.slice();
            turn.winningTurn = snap.winningTurn;

            exitEditMode();
        }

        function exitEditMode() {
            document.body.classList.remove('edit-mode');
            originalTurnSnapshot = null;
            editingPosition = null;

            // Return to last rack/turn
            match.currentRack = match.racks.length - 1;
            match.currentTurn = match.racks[match.currentRack].turns.length - 1;

            updateLabels(match.getTurn());
            updateButtons(match.getTurn());
            document.getElementById('score').textContent = '';
            document.getElementById('score').insertAdjacentHTML('beforeend', scoreToString(match.score));
        }

        function applyHistoricalEdit() {
            const pos = editingPosition;

            // Truncate turns after the edited position in current rack
            match.racks[pos.rack].turns.length = pos.turn + 1;

            // Remove all subsequent racks
            match.racks.length = pos.rack + 1;

            // Recalculate all scores
            recalculateAllScores();

            // Set current position to edited turn
            match.currentRack = pos.rack;
            match.currentTurn = pos.turn;

            // Exit edit mode
            document.body.classList.remove('edit-mode');
            originalTurnSnapshot = null;
            editingPosition = null;

            // Update display
            updateLabels(match.getTurn());
            updateButtons(match.getTurn());
            document.getElementById('score').textContent = '';
            document.getElementById('score').insertAdjacentHTML('beforeend', scoreToString(match.score));
        }

        function recalculateAllScores() {
            // Reset score aggregates
            match.score = {
                player1: {
                    racksWon: 0,
                    ballsPotted: 0,
                    missErrors: 0,
                    breakErrors: 0,
                    kickErrors: 0,
                    safetyErrors: 0,
                    positionError: 0
                },
                player2: {
                    racksWon: 0,
                    ballsPotted: 0,
                    missErrors: 0,
                    breakErrors: 0,
                    kickErrors: 0,
                    safetyErrors: 0,
                    positionError: 0
                }
            };

            // Store original position
            const savedRack = match.currentRack;
            const savedTurn = match.currentTurn;

            // Iterate through all completed turns and recalculate
            for (let r = 1; r < match.racks.length; r++) {
                for (let t = 1; t < match.racks[r].turns.length; t++) {
                    const turn = match.racks[r].turns[t];

                    // Only update score for completed turns (those with score snapshot)
                    if (turn.hasBeenPlayed() && turn.score !== null) {
                        match.currentRack = r;
                        match.currentTurn = t;
                        match.updateScore(turn);
                        turn.score = scoreToString(match.score);
                    }
                }
            }

            // Restore position
            match.currentRack = savedRack;
            match.currentTurn = savedTurn;
        }

        // Function that takes a list of kick-ins and kick-outs and returns a string with the kick sequence
        function kickSequence(kickIn) {
            let kickSequence = '';
            for (let i = 0; i < kickIn.length; i++) {
                if (kickIn[i].isFirst) 
                    kickSequence += `<span class="circle-kick"><label class="fs-6 col-1">${kickIn[i].player}</label></span>`;
                else
                    kickSequence += `<label class="fs-6 col-1">${kickIn[i].player}</label>`;
            }
            return kickSequence;
        }

        function totalErrors(player) {
            return player.missErrors + player.breakErrors + player.kickErrors + player.safetyErrors + player.positionError;
        }

        function tpaScore(player) {
            const total = player.ballsPotted + totalErrors(player);
            if (total === 0) return '-';
            return Math.trunc(player.ballsPotted / total * 1000);
        }

        function gameTypeName(gameType) {
            const names = { 8: '8-Ball', 9: '9-Ball', 10: '10-Ball' };
            return names[gameType] || gameType + '-Ball';
        }

        function formatAchievements(player) {
            const parts = [];
            if (displaySettings.showBR) parts.push(`BR:${player.breakAndRuns || 0}`);
            if (displaySettings.showRO) parts.push(`RO:${player.runOuts || 0}`);
            if (displaySettings.showPR) parts.push(`PR:${player.perfectRacks || 0}`);
            return parts.length > 0 ? parts.join(' ') : '-';
        }

        // Compact format for player section display (e.g., "BR1 RO0")
        function formatAchievementsCompact(player) {
            const parts = [];
            if (displaySettings.showBR) parts.push(`BR${player.breakAndRuns || 0}`);
            if (displaySettings.showRO) parts.push(`RO${player.runOuts || 0}`);
            if (displaySettings.showPR) parts.push(`PR${player.perfectRacks || 0}`);
            return parts.join(' ');
        }

        function formatErrorsByType(player) {
            const parts = [];
            if (player.missErrors > 0) parts.push(`M${player.missErrors}`);
            if (player.breakErrors > 0) parts.push(`B${player.breakErrors}`);
            if (player.kickErrors > 0) parts.push(`K${player.kickErrors}`);
            if (player.safetyErrors > 0) parts.push(`S${player.safetyErrors}`);
            if (player.positionError > 0) parts.push(`P${player.positionError}`);
            return parts.length > 0 ? parts.join('/') : '0';
        }

        function formatPlayerStats(player) {
            if (displaySettings.errorDisplay === 'byType') {
                return `B${player.ballsPotted} ${formatErrorsByType(player)}`;
            }
            return `B${player.ballsPotted} E${totalErrors(player)}`;
        }

        function scoreToString(score) {
            const tpa1 = tpaScore(score.player1);
            const tpa2 = tpaScore(score.player2);
            const stats1 = formatPlayerStats(score.player1);
            const stats2 = formatPlayerStats(score.player2);
            let achievementsRow = '';
            const showAnyAchievement = displaySettings.showBR || displaySettings.showRO || displaySettings.showPR;
            if (showAnyAchievement) {
                const achieve1 = formatAchievements(score.player1);
                const achieve2 = formatAchievements(score.player2);
                if (achieve1 !== '-' || achieve2 !== '-') {
                    achievementsRow = `<div class="score-achievements">${achieve1} | ${achieve2}</div>`;
                }
            }
            return `<div class="score-display">
                <div class="score-racks"><strong>${score.player1.racksWon} - ${score.player2.racksWon}</strong></div>
                <div class="score-tpa"><span class="score-stats">${stats1}</span> <span class="tpa-value">${tpa1}</span> TPA <span class="tpa-value">${tpa2}</span> <span class="score-stats">${stats2}</span></div>
                ${achievementsRow}
            </div>`;
        }

        function togglePlayer(event) {
            // The id of the clicked element is player1Label or player2Label. I extract the character after player and compare it with the currentPlayer. If it is different, I change the currentPlayer.
            if ((event.target.id === 'player1Label' || event.target.id === 'player2Label') && !event.target.id.includes(match.currentPlayer)) {
                match.togglePlayer();
                updateLabels(match.getTurn());
                updateButtons(match.getTurn());
                //score update
                document.getElementById('score').innerHTML = scoreToString(match.score);
                updatePlayerDisplay();
                // If the current turn is a break, show endMatch, otherwise hide it
                if (match.getTurn().isBreak()) {
                    document.getElementById('endMatch').classList.add('d-flex');
                } else {
                    document.getElementById('endMatch').classList.remove('d-flex');
                }
                // Update history navigation buttons
                updateHistoryNavButtons();
                saveMatchState();
            }
        }

        function selectPlayer(playerNum) {
            if (!match || match.currentPlayer === playerNum) return;
            if (!match.canSwitchPlayer()) return;

            // Simulate click on the appropriate label
            const event = { target: { id: `player${playerNum}Label` } };
            togglePlayer(event);
        }

        function updatePlayerDisplay() {
            if (!match) return;

            // Update racks won
            document.getElementById('player1Racks').textContent = match.score.player1.racksWon;
            document.getElementById('player2Racks').textContent = match.score.player2.racksWon;

            // Update achievements (BR/RO/PR based on settings)
            document.getElementById('player1Achievements').textContent = formatAchievementsCompact(match.score.player1);
            document.getElementById('player2Achievements').textContent = formatAchievementsCompact(match.score.player2);

            // Update TPA
            document.getElementById('player1Tpa').textContent = tpaScore(match.score.player1);
            document.getElementById('player2Tpa').textContent = tpaScore(match.score.player2);

            // Update Stats (Balls and Errors - format depends on settings)
            document.getElementById('player1Stats').textContent = formatPlayerStats(match.score.player1);
            document.getElementById('player2Stats').textContent = formatPlayerStats(match.score.player2);

            // Update active player styling
            const label1 = document.getElementById('player1Label');
            const label2 = document.getElementById('player2Label');
            if (match.currentPlayer === 1) {
                label1.classList.add('active');
                label2.classList.remove('active');
            } else {
                label1.classList.remove('active');
                label2.classList.add('active');
            }
        }

        function showPlayerStatsFromMatch(playerNum) {
            if (!match) return;
            const playerName = match.players[playerNum - 1].name;
            document.getElementById('statsPlayerSelect').value = playerName;
            showStatsView();
        }

        function updateSwitchPlayerStatus() {
            const radioButtons = document.querySelectorAll('#playersGroup input[type="radio"]');
            const canSwitch = match.canSwitchPlayer();

            // Enable or disable the radio buttons based on the checkbox
            radioButtons.forEach(radio => {
                radio.disabled = !canSwitch;
                if (radio.id === `player${match.currentPlayer}Option`) {
                    radio.checked = true;
                }
            });

            // Update the style of the player name labels to reflect the disabled state
            const label1 = document.getElementById('player1Label');
            const label2 = document.getElementById('player2Label');
            if (!canSwitch) {
                label1.classList.add('disabled');
                label2.classList.add('disabled');
            } else {
                label1.classList.remove('disabled');
                label2.classList.remove('disabled');
            }
        }

        document.getElementById('playersGroup').addEventListener('click', togglePlayer);

        // Add click listeners to new player labels
        document.getElementById('player1Label').addEventListener('click', togglePlayer);
        document.getElementById('player2Label').addEventListener('click', togglePlayer);

        // Add click listeners to annotation cells that reset the current turn or enter edit mode
        function handleAnnotationClick() {
            if (!match) return;
            if (match.isHistoryMode) {
                // In history mode: show confirmation and edit
                enterEditMode();
            } else {
                // Normal behavior: reset current turn
                match.getTurn().tpaAnnotation.reset();
                match.getTurn().winningTurn = false;
                updateLabels(match.getTurn());
                updateButtons(match.getTurn());
                saveMatchState();
            }
        }
        document.getElementById('circle1').addEventListener('click', handleAnnotationClick);
        document.getElementById('circle2').addEventListener('click', handleAnnotationClick);
        document.getElementById('grayLabel1').addEventListener('click', handleAnnotationClick);
        document.getElementById('grayLabel2').addEventListener('click', handleAnnotationClick);

        function htmlDivAnnotation(turn) {
            let kickSequence = '&nbsp;';
            for (let i = 0; i < turn.tpaAnnotation.kickSequence.length; i++) {
                if (turn.tpaAnnotation.kickSequence[i].player === turn.player) {
                    kickSequence += `<span class="circle-kick"><label class="col-1">${turn.tpaAnnotation.kickSequence[i].player}</label></span>`;
                }
            }
            let whiteLabelText = '';
            if (turn.tpaAnnotation.breakPotted) {//if breakPotted is defined and not null
                whiteLabelText += `<sup>${turn.tpaAnnotation.breakPotted}</sup>`;
            }
            whiteLabelText += `${turn.tpaAnnotation.totalPotted !== null ? (turn.tpaAnnotation.totalPotted >= 0 ? turn.tpaAnnotation.totalPotted : '') : ''}`;
            whiteLabelText += ` ${turn.tpaAnnotation.mainNote()}`;
            let circleBorder = turn.isWinning() ? "2px solid black" : "none";
            return `<div class="mb-1">${kickSequence}</div>
                    <div class="align-items-center">
                        <div class="row">
                            <div class="d-flex justify-content-center">
                                <span class="circle" style="border: ${circleBorder}">
                                    <label class="white-label d-flex">${whiteLabelText}</label>
                                </span>
                                <label class="border gray-label d-flex">${turn.tpaAnnotation.secondaryNote()}</label>
                            </div>
                        </div>
                    </div>`;

        }

        function endMatch() {
            var confirmation = window.confirm("This will end the match.\nAre you sure?");
          
            if (!confirmation) return;
            clearMatchState(); // Clear saved state since match is ending
            // Builds an HTML table with all the turns and annotations
            // Hides main and endMatch, shows results
            // Iterates through all the racks and turns and adds them to the table
            // The table has two columns, one for the first player and one for the second player
            // The headers are the names of the players
            // Each row displays the annotations for the turn
            // At the end of each rack, a wide row with the rack score is added
            const results = document.createElement('table');
            results.classList.add('table');
            results.innerHTML = `
                <thead>
                    <tr>
                        <th scope="col">${match.players[0].name}</th>
                        <th scope="col">${match.players[1].name}</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            `;
            const tbody = results.querySelector('tbody');
            for (let i = 1; i < match.racks.length-1; i++) {//when calling endMatch the last rack is always empty
                let row = document.createElement('tr');
                for (let j = 1; j < match.racks[i].turns.length; j++) {
                    const turn = match.racks[i].turns[j];
                    if (turn.player === 2) {
                        if (j === 1) {
                            row = document.createElement('tr');
                            row.innerHTML = `<td></td><td>${htmlDivAnnotation(turn)}</td>`;
                        } else {// it's not the first turn, so the second player needs to be added to the row
                            row.innerHTML += `<td>${htmlDivAnnotation(turn)}</td>`;
                        }
                    } else {// the player is the first
                        row = document.createElement('tr');
                        row.innerHTML = `<td>${htmlDivAnnotation(turn)}</td>`;                      
                    }
                    tbody.appendChild(row);
                    //if the turn is the last of the rack, add a row with the rack score
                    if (j === match.racks[i].turns.length - 1) {
                        let scoreRow = document.createElement('tr');
                        scoreRow.innerHTML = `<td colspan="2">${turn.score}</td>`;
                        tbody.appendChild(scoreRow);
                        if (i === match.racks.length - 2) {//if it's the last rack, add the final score
                            let finalScoreRow = document.createElement('tr');
                            finalScoreRow.innerHTML = `
                                <td>
                                    <div class="d-flex justify-content-between">
                                      <div>
                                        <p class="mb-0 ps-2 text-start">miss errs:</p>
                                        <p class="mb-0 ps-2 text-start">break errs:</p>
                                        <p class="mb-0 ps-2 text-start">kick errs:</p>
                                        <p class="mb-0 ps-2 text-start">safety errs:</p>
                                        <p class="mb-0 ps-2 text-start">position errs:</p>
                                        <hr class="my-1">
                                        <p class="mb-0 ps-2 text-start text-success">break & runs:</p>
                                        <p class="mb-0 ps-2 text-start text-success">run outs:</p>
                                        <p class="mb-0 ps-2 text-start text-success">perfect racks:</p>
                                      </div>
                                      <div class="text-right">
                                        <p class="mb-0 pe-2 text-end">${match.score.player1.missErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player1.breakErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player1.kickErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player1.safetyErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player1.positionError}</p>
                                        <hr class="my-1">
                                        <p class="mb-0 pe-2 text-end text-success">${match.score.player1.breakAndRuns}</p>
                                        <p class="mb-0 pe-2 text-end text-success">${match.score.player1.runOuts}</p>
                                        <p class="mb-0 pe-2 text-end text-success">${match.score.player1.perfectRacks}</p>
                                      </div>
                                    </div>
                                  </td>
                                  <td>
                                    <div class="d-flex justify-content-between">
                                      <div>
                                        <p class="mb-0 ps-2 text-start">miss errs:</p>
                                        <p class="mb-0 ps-2 text-start">break errs:</p>
                                        <p class="mb-0 ps-2 text-start">kick errs:</p>
                                        <p class="mb-0 ps-2 text-start">safety errs:</p>
                                        <p class="mb-0 ps-2 text-start">position errs:</p>
                                        <hr class="my-1">
                                        <p class="mb-0 ps-2 text-start text-success">break & runs:</p>
                                        <p class="mb-0 ps-2 text-start text-success">run outs:</p>
                                        <p class="mb-0 ps-2 text-start text-success">perfect racks:</p>
                                      </div>
                                      <div class="text-right">
                                        <p class="mb-0 pe-2 text-end">${match.score.player2.missErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player2.breakErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player2.kickErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player2.safetyErrors}</p>
                                        <p class="mb-0 pe-2 text-end">${match.score.player2.positionError}</p>
                                        <hr class="my-1">
                                        <p class="mb-0 pe-2 text-end text-success">${match.score.player2.breakAndRuns}</p>
                                        <p class="mb-0 pe-2 text-end text-success">${match.score.player2.runOuts}</p>
                                        <p class="mb-0 pe-2 text-end text-success">${match.score.player2.perfectRacks}</p>
                                      </div>
                                    </div>
                                  </td>`;
                            tbody.appendChild(finalScoreRow);                    
                        }
                    }
                }
            }
            document.getElementById('results').appendChild(results);
            document.getElementById('main').style.display = 'none';
            document.getElementById('endMatch').classList.remove('d-flex');
            document.getElementById('results').style.display = 'block';

            // Save match to IndexedDB
            const matchRecord = {
                id: generateUUID(),
                date: match.startDate,
                gameType: parseInt(match.gameType),
                players: match.players,
                finalScore: {
                    player1: {
                        racksWon: match.score.player1.racksWon,
                        ballsPotted: match.score.player1.ballsPotted,
                        missErrors: match.score.player1.missErrors,
                        breakErrors: match.score.player1.breakErrors,
                        kickErrors: match.score.player1.kickErrors,
                        safetyErrors: match.score.player1.safetyErrors,
                        positionError: match.score.player1.positionError,
                        runOuts: match.score.player1.runOuts,
                        breakAndRuns: match.score.player1.breakAndRuns,
                        perfectRacks: match.score.player1.perfectRacks,
                        tpaScore: tpaScore(match.score.player1)
                    },
                    player2: {
                        racksWon: match.score.player2.racksWon,
                        ballsPotted: match.score.player2.ballsPotted,
                        missErrors: match.score.player2.missErrors,
                        breakErrors: match.score.player2.breakErrors,
                        kickErrors: match.score.player2.kickErrors,
                        safetyErrors: match.score.player2.safetyErrors,
                        positionError: match.score.player2.positionError,
                        runOuts: match.score.player2.runOuts,
                        breakAndRuns: match.score.player2.breakAndRuns,
                        perfectRacks: match.score.player2.perfectRacks,
                        tpaScore: tpaScore(match.score.player2)
                    }
                },
                htmlTable: results.outerHTML,
                syncedToCloud: false,
                createdAt: Date.now(),
                updatedAt: Date.now()
            };

            // Save to IndexedDB
            tpaDB.saveMatch(matchRecord).catch(error => {
                console.error('Error saving to IndexedDB:', error);
            });

            // Sync to Google Sheets if enabled
            (async function() {
                const autoSync = await isAutoSyncEnabled();
                if (autoSync) {
                    const googleSheetURL = await getGoogleSheetUrl();
                    const matchData = {
                        date: match.startDate,
                        player1: match.players[0].name,
                        player2: match.players[1].name,
                        player1Score: tpaScore(match.score.player1),
                        player2Score: tpaScore(match.score.player2),
                        player1RacksWon: match.score.player1.racksWon,
                        player2RacksWon: match.score.player2.racksWon,
                        player1BallsPotted: match.score.player1.ballsPotted,
                        player2BallsPotted: match.score.player2.ballsPotted,
                        player1MissErrors: match.score.player1.missErrors,
                        player2MissErrors: match.score.player2.missErrors,
                        player1BreakErrors: match.score.player1.breakErrors,
                        player2BreakErrors: match.score.player2.breakErrors,
                        player1KickErrors: match.score.player1.kickErrors,
                        player2KickErrors: match.score.player2.kickErrors,
                        player1SafetyErrors: match.score.player1.safetyErrors,
                        player2SafetyErrors: match.score.player2.safetyErrors,
                        player1PositionError: match.score.player1.positionError,
                        player2PositionError: match.score.player2.positionError,
                        gameType: match.gameType,
                        htmlTable: results.outerHTML
                    };

                    fetch(googleSheetURL, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(matchData)
                    })
                    .then(() => {
                        tpaDB.markAsSynced(matchRecord.id);
                    })
                    .catch(error => {
                        console.error('Error syncing to Google Sheets:', error);
                    });
                }
            })();
        }

    </script>
</body>

</html>