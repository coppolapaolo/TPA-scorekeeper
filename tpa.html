<!doctype html>
<html>

<head>
    <title>Player Match</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.5.1/chart.min.js"></script>
    <style>
        .container {
            max-width: 960px;
        }

        .btn {
            height: 70px;
            vertical-align: middle;
        }
        .circle {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            border: 2px solid black;
            pointer-events: none;
        }
            .circle-kick {
            position: relative;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            border: 2px solid black;
            padding: 1px;
        }

        .circle-kick .fs-6 {
            margin: 0;
        }

        .circle label, .circle-kick label {
            margin: 0;
        }

        .white-label, .gray-label {
            /* diplay: flex; */
            justify-content: center;
            align-items: center;
            vertical-align: middle;
            height: 70px;
            font-size: 1.5em;
        }
        .white-label {
            width: 70px; 
            border: 1px solid black;
        }
        .gray-label {
            width: 35px; /* half of whiteLabel */
            background-color: lightgray;
        }
        #player1Label, #player2Label, #whiteLabel1, #whiteLabel2, #grayLabel1, #grayLabel2 {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 70px; /* Fixed height to ensure enough space for center alignment */
        }
        #circle1, #circle2 {
            position: relative;
            width: 68px;
            height: 68px;
        }
        .btn-square {
            width: 50px;
            height: 50px;
            margin: 0.3em;
        }
        table, td, th, tr {
            border: 2px solid black;
            text-align: center;
        }
    
    </style>
    <meta charset="utf-8">
</head>

<body class="p-3 m-0">
    <form id="playerForm" class="mb-5 d-flex row justify-content-center">
        <div class="form-group">
            <label for="player1">Player 1</label>
            <input type="text" class="form-control" id="player1" placeholder="Inserisci il nome del giocatore 1"
                onchange="saveNames()">
        </div>
        <div class="form-group">
            <label for="player2">Player 2</label>
            <input type="text" class="form-control" id="player2" placeholder="Inserisci il nome del giocatore 2"
                onchange="saveNames()">
        </div>
        <button type="button" class="btn btn-primary col-5" style="margin: .5em;" onclick="startMatch()">Start</button>
    </form>

    <h3 id="dateTitle" class="text-center mb-3" style="display: none;">DATA</h3>
        
    <div id="main" class="container text-center" style="display: none;">
        <div class="row  align-items-center">
            <div id="kicks" class="col-5 offset-6 mb-1">
                <span class="circle-kick">
                    <label class="fs-6 col-1">1</label>
                </span>
                <label class="fs-6 col-1">1</label>
                <span class="circle-kick">
                    <label class="fs-6 col-1">2</label>
                </span>
                <label class="fs-6 col-1">2</label>
                <label class="fs-6 col-1">2</label>
            </div>
            <div id="playersGroup" class="col-5 btn-group-vertical offset-1" role="group">
                <input type="radio" class="btn-check" name="playerOption" id="player1Option" autocomplete="off" checked>
                <label id="player1Label" class="btn btn-outline-primary mb-3" for="player1Option">Player1</label>

                <input type="radio" class="btn-check" name="playerOption" id="player2Option" autocomplete="off">
                <label id="player2Label" class="btn btn-outline-primary" for="player2Option">Player2</label>
            </div>
            <div id="divPlayers" class="col-6 align-content-center">
                <div id="divPlayerLabel1" class="row mb-3 justify-content-start align-items-center">
                    <div id="divWhiteLabel1" class="d-flex col-5 offset-1 justify-content-end">
                        <span id="circle1" class="circle">
                            <label id="whiteLabel1" class="white-label"><sup>3</sup>5M</label>
                        </span>
                    </div>
                    <div id="divGrayLabel1" class="col-3 justify-content-start">
                        <label id="grayLabel1" class="border gray-label">P</label>
                    </div>
                </div>

                <div id="divPlayerLabel2" class="row align-items-center">
                    <div id="divWhiteLabel2" class="d-flex col-5 offset-1 justify-content-end">
                        <span id="circle2" class="circle">
                            <label id="whiteLabel2" class="white-label"><sup>3</sup>5M</label>
                        </span>
                    </div>
                    <div id="divGrayLabel2" class="col-3">
                        <label id="grayLabel2" class="border gray-label">P</label>
                    </div>
                </div>
            </div>
            <div id="score" class="col-9 offset-1">(0,0,NaN) <strong>0 - 0</strong> (0,0,NaN)</div>
        </div>
        <div id="scoreButtons" class="container mt-2" style="display: block;">
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="button1" class="btn btn-secondary btn-square">1</button>
                </div>
                <div class="col-2">
                    <button type="button" id="button2" class="btn btn-secondary btn-square">2</button>
                </div>
                <div class="col-2">
                    <button type="button" id="button3" class="btn btn-secondary btn-square">3</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="button4" class="btn btn-secondary btn-square">4</button>
                </div>
                <div class="col-2">
                    <button type="button" id="button5" class="btn btn-secondary btn-square">5</button>
                </div>
                <div class="col-2">
                    <button type="button" id="button6" class="btn btn-secondary btn-square">6</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="button7" class="btn btn-secondary btn-square">7</button>
                </div>
                <div class="col-2">
                    <button type="button" id="button8" class="btn btn-secondary btn-square">8</button>
                </div>
                <div class="col-2">
                    <button type="button" id="button9" class="btn btn-secondary btn-square">9</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="button0" class="btn btn-secondary btn-square">0</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="buttonM" class="btn btn-secondary btn-square">M</button>
                </div>
                <div class="col-2">
                    <button type="button" id="buttonK" class="btn btn-secondary btn-square">K</button>
                </div>
                <div class="col-2">
                    <button type="button" id="buttonS" class="btn btn-secondary btn-square">S</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="buttonP" class="btn btn-secondary btn-square">P</button>
                </div>
                <div class="col-2">
                    <button type="button" id="buttonG" class="btn btn-secondary btn-square">G</button>
                </div>
                <div class="col-2">
                    <button type="button" id="buttonN" class="btn btn-secondary btn-square">N</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-2">
                    <button type="button" id="buttonn" class="btn btn-secondary btn-square">n</button>
                </div>
                <div class="col-2">
                    <button type="button" id="buttonx" class="btn btn-secondary btn-square">x</button>
                </div>
                <div class="col-2">
                    <button type="button" id="buttonp" class="btn btn-secondary btn-square">p</button>
                </div>
            </div>
            <div class="row justify-content-center mb-2">
                <div class="col-5">
                    <button type="button" id="buttonK-in" class="btn btn-secondary" style="width: 150px; height: 40px; margin: 0.3em">first shot kick-in</button>
                </div>
            </div>
        </div>
    </div>
    <div id="endMatch" class="justify-content-center" style="display: none;">
        <button type="button" class="btn btn-primary col-7" onclick="endMatch()">End Match</button>
    </div>
    <div id="results" class="container justify-content-center mb-5 flex-column" style="display: none;">
    </div>


    <script>
        function getCookie(cname) {
            var name = cname + "=";
            var decodedCookie = decodeURIComponent(document.cookie);
            var ca = decodedCookie.split(';');
            for (var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) == ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(name) == 0) {
                    return c.substring(name.length, c.length);
                }
            }
            return "";
        }

        window.onload = function () {
            var player1 = getCookie('player1');
            if (player1 != "") {
                document.getElementById('player1').value = player1;
            }

            var player2 = getCookie('player2');
            if (player2 != "") {
                document.getElementById('player2').value = player2;
            }
        };

        function saveNames() {
            var player1 = document.getElementById('player1').value;
            var player2 = document.getElementById('player2').value;

            var d = new Date();
            d.setTime(d.getTime() + (60 * 60 * 24 * 60 * 1000)); // Two months
            var expires = "expires=" + d.toUTCString();

            document.cookie = "player1=" + player1 + ";" + expires + ";path=/";
            document.cookie = "player2=" + player2 + ";" + expires + ";path=/";
        }

        function formatDateTime(date) {
            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, '0'); // Months start from 0
            const dd = String(date.getDate()).padStart(2, '0');
            const hh = String(date.getHours()).padStart(2, '0');
            const min = String(date.getMinutes()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd} ${hh}:${min}`;
        }

        class Match {
            constructor(player1name, player2name) {
                this.startDate = formatDateTime(new Date()); // Current date and time
                this.players = [
                    { name: player1name },
                    { name: player2name }
                ];
                this.score = {
                    player1: { 
                        racksWon: 0, 
                        ballsPotted: 0, 
                        missErrors: 0, 
                        breakErrors: 0, 
                        kickErrors: 0, 
                        safetyErrors: 0, 
                        positionError: 0
                    },
                    player2: { 
                        racksWon: 0, 
                        ballsPotted: 0, 
                        missErrors: 0, 
                        breakErrors: 0,
                        kickErrors: 0,
                        safetyErrors: 0,
                        positionError: 0
                    }
                };
                // add a dummy element to the racks to have the first rack with index 1 instead of 0
                this.racks = [null];
                this.currentRack = 1;
                this.currentTurn = 1;
                this.currentPlayer = 1;
                this.racks.push({turns:[null, new Turn(this.currentPlayer,true,9)]});
            }

            annotate(event) {// button listener
                // buttons have ids buttonX where X is a number or a letter
                const buttonID = event.target.id;
                const buttonValue = parseInt(buttonID[6]);
                if (buttonValue === 0) {
                    this.getTurn().tpaAnnotation.totalPotted = 0;
                    if (this.getTurn().isBreak()) {
                        this.getTurn().tpaAnnotation.breakPotted = this.getTurn().tpaAnnotation.breakPotted === null ? 0 : this.getTurn().tpaAnnotation.breakPotted;
                    }
                } else if (!isNaN(buttonValue)) {
                    if (this.getTurn().isBreak()) {
                        if (this.getTurn().tpaAnnotation.breakPotted === null) {
                            this.getTurn().tpaAnnotation.breakPotted = buttonValue;
                        } else {
                            this.getTurn().tpaAnnotation.totalPotted = buttonValue;
                        }
                    } else {
                        this.getTurn().tpaAnnotation.totalPotted = buttonValue;
                    }
                } else {
                    switch (buttonID) {
                        case 'buttonM':
                            this.getTurn().tpaAnnotation.missErrors = 1;
                            this.getTurn().tpaAnnotation.safety = false;
                            this.getTurn().tpaAnnotation.kick = false;
                            break;
                        case 'buttonK':
                            this.getTurn().tpaAnnotation.kick = true;
                            this.getTurn().tpaAnnotation.missErrors = 0;
                            this.getTurn().tpaAnnotation.safety = false;
                            break;
                        case 'buttonS':
                            this.getTurn().tpaAnnotation.safety = true;
                            this.getTurn().tpaAnnotation.kick = false;
                            this.getTurn().tpaAnnotation.missErrors = 0;
                            break;
                        case 'buttonG':
                            this.getTurn().setWinningTurn();
                            break;
                        case 'buttonP':
                            this.getTurn().tpaAnnotation.pocketed = this.getTurn().tpaAnnotation.pocketed === null ? true : !this.getTurn().tpaAnnotation.pocketed;
                            this.getTurn().tpaAnnotation.noHit = false;
                            break;
                        case 'buttonN':
                            this.getTurn().tpaAnnotation.noHit = this.getTurn().tpaAnnotation.noHit === null ? true : !this.getTurn().tpaAnnotation.noHit;
                            this.getTurn().tpaAnnotation.pocketed = false;
                            break;
                        case 'buttonn': 
                            this.getTurn().tpaAnnotation.missErrors =  this.getTurn().tpaAnnotation.missErrors === 2 ? 1 : 2;
                            break;
                        case 'buttonx': 
                            this.getTurn().tpaAnnotation.safeX = this.getTurn().tpaAnnotation.safeX === null ? true : !this.getTurn().tpaAnnotation.safeX;
                            this.getTurn().tpaAnnotation.push = false;
                            break;
                        case 'buttonp': 
                            this.getTurn().tpaAnnotation.push = this.getTurn().tpaAnnotation.push === null ? true : !this.getTurn().tpaAnnotation.push;
                            this.getTurn().pushed = this.getTurn().tpaAnnotation.push;
                            this.getTurn().tpaAnnotation.safeX = false;
                            break;
                    }
                }
                updateLabels(this.getTurn());
                updateButtons(this.getTurn());

            }

            getTurn() {
                return this.racks[this.currentRack].turns[this.currentTurn];
            }

            canSwitchPlayer() {
                if (!this.getTurn().hasBeenPlayed()) {
                    return this.getTurn().isBreak() && this.getTurn().tpaAnnotation.breakPotted === null;
                } else if (this.getTurn().isWinning()) {
                    return true;
                } else if (this.getTurn().isBreak() && this.getTurn().tpaAnnotation.breakPotted === 0 && this.getTurn().tpaAnnotation.totalPotted === 0) {
                    return true;
                } else if(this.getTurn().isBreak() && this.getTurn().tpaAnnotation.breakPotted > 0 && this.getTurn().tpaAnnotation.totalPotted === 0 && (this.getTurn().tpaAnnotation.noHit || this.getTurn().tpaAnnotation.pocketed)) {
                    return true;
                } else if (!this.getTurn().tpaAnnotation.kick && !this.getTurn().tpaAnnotation.safety && !this.getTurn().tpaAnnotation.missErrors) {
                    return false;
                } else return true;
            }

            togglePlayer() {
            /*
            Updates the current player.

            If the previous turn was a winning turn, adds a new rack to the match and initializes a new turn.
            Otherwise, adds a new turn to the current rack.

            If a toggle was just performed (the current turn has not been played), it simply changes the player of the current turn without adding a new turn.

            Also updates the score based on the annotations and the potential winning of the turn.
            */
                this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                if (!this.racks[this.currentRack].turns[this.currentTurn].hasBeenPlayed() && this.getTurn().isBreak()) {
                    this.racks[this.currentRack].turns[this.currentTurn].player = this.currentPlayer;
                } else {
                    this.updateScore(this.racks[this.currentRack].turns[this.currentTurn]);
                    this.getTurn().score = scoreToString(this.score);
                    if (this.racks[this.currentRack].turns[this.currentTurn].isWinning()) {
                        this.racks.push({ turns: [null] });
                        this.currentRack++;
                        this.currentTurn = 1;
                        this.racks[this.currentRack].turns.push(new Turn(this.currentPlayer,true,9));
                    } else {
                        let ballsRemaining = this.getTurn().ballsRemaining - Math.max(this.getTurn().tpaAnnotation.totalPotted,this.getTurn().tpaAnnotation.breakPotted);
                        // Almost impossible case of 9 balls potted on the break and cue ball in pocket or foul
                        if (this.getTurn().tpaAnnotation.breakPotted === 9 && this.getTurn().tpaAnnotation.totalPotted === 0) {
                            ballsRemaining = 1;
                        }
                        let pushed = this.getTurn().isPushed() && (this.getTurn().isBreak() || (this.getTurn().isPushed() && this.getTurn().previousTurn.isBreak() && this.getTurn().previousTurn.tpaAnnotation.totalPotted === 0 && this.getTurn().tpaAnnotation.totalPotted === 0));
                        this.currentTurn++;
                        this.racks[this.currentRack].turns.push(new Turn(this.currentPlayer,false,ballsRemaining));
                        this.getTurn().previousTurn = this.racks[this.currentRack].turns[this.currentTurn-1];
                        if (pushed) {
                            this.getTurn().push();
                        }
                    }
                }
            }

            updateScore(turn) {
                /* Calculate errors:
                - breakErrors: if it's a break and ended with noHit or pocketed
                - missErrors: if it's a miss. It can be 1 or 2
                - kickErrors: if it's a kick ended with noHit or pocketed
                - safetyErrors: calculated for the player of the previous turn, if they made a safety and the current player has potted at least one ball. If kick-in, it's not counted
                - positionError: if it's not a missError of 2, if it's not safeX, hasn't won, and has potted at least one ball (unless it's a safe or a push with totalpotted > 0 but === to breakpotted). Or if pocketed is true or noHit is true, but not kick or break
                */ 
                const scorePlayer = this.score[`player${turn.player}`];
                if (turn.isWinning()) {
                    scorePlayer.racksWon++;
                }
                //update missErrors
                if (turn.tpaAnnotation.missErrors) {
                    scorePlayer.missErrors+=turn.tpaAnnotation.missErrors;
                }
                //update breakErrors
                if (turn.isBreak() && (turn.tpaAnnotation.noHit || turn.tpaAnnotation.pocketed)) {
                    scorePlayer.breakErrors++;
                }
                //update kickErrors
                if (turn.tpaAnnotation.kick && (turn.tpaAnnotation.noHit || turn.tpaAnnotation.pocketed)) {
                    scorePlayer.kickErrors++;
                }
                // Update safetyErrors only if it's not the first turn
                if (this.currentTurn > 1) {
                    const previousTurn = this.racks[this.currentRack].turns[this.currentTurn-1];
                    // here I assume that only kick-ins are recorded on the first shot
                    if (previousTurn.tpaAnnotation.safety && turn.tpaAnnotation.totalPotted > 0 && turn.tpaAnnotation.kickSequence.length === 0) {
                        this.score[`player${previousTurn.player}`].safetyErrors++;
                    }
                }
                //update positionError
                if (turn.tpaAnnotation.missErrors !== 2 && !turn.tpaAnnotation.safeX && !turn.isWinning() && turn.tpaAnnotation.totalPotted > 0) {
                    if (turn.tpaAnnotation.breakPotted != turn.tpaAnnotation.totalPotted) {
                        scorePlayer.positionError++;
                    }
                } else if (turn.tpaAnnotation.pocketed || turn.tpaAnnotation.noHit) {
                    if (!turn.tpaAnnotation.kick && !turn.tpaAnnotation.safety && !turn.tpaAnnotation.missErrors) {
                        scorePlayer.positionError++;
                    }
                }
                scorePlayer.ballsPotted += turn.tpaAnnotation.totalPotted;
            }
        }

        class TPAAnnotation {

            constructor() {
                this.totalPotted = null;
                this.breakPotted = null;
                this.missErrors = null;// can be 0, 1, 2
                this.kick = null;
                this.pocketed = null;
                this.safety = null;
                this.push = null;
                this.safeX = null;
                this.noHit = null;
                this.kickSequence = [];
            }

            reset() {
                this.totalPotted = null;
                this.breakPotted = null;
                this.missErrors = null;
                this.kick = null;
                this.pocketed = null;
                this.safety = null;
                this.push = null;
                this.safeX = null;
                this.noHit = null;
                this.kickSequence = [];
            }

            ballsAnnotated() {
                return this.totalPotted !== null;
            }


            mainNote() {
                if (this.kick) {
                    return 'K';
                } else if (this.safety) {
                    if (this.safeX) {
                        return 'S<sup>x</sup>';
                    } else if (this.push) {
                        return 'S<sup>p</sup>';
                    } else {
                        return 'S';
                    }
                } else if (this.missErrors == 2) {
                    return 'M<sup>n</sup>';
                } else if (this.missErrors == 1) {
                    return 'M';
                }
                return '';
            }

            secondaryNote() {
                if (this.noHit) {
                    return 'N';
                } else if (this.pocketed) {
                    return 'P';
                }
                return '';
            }

            hasKickIn() {
                return this.kickSequence.length > 0;
            }
        }

        class KickIn {
            constructor(player, isFirst) {
                this.player = player;
                this.isFirst = isFirst;
            }
        }
        
        class Turn {
            constructor(player, breakShot, ballsRemaining) {
                /* breakShot is a boolean, ballsRemaining is an integer, tpaAnnotation is a TPAAnnotation object */
                this.player = player;
                this.breakShot = breakShot;
                this.ballsRemaining = ballsRemaining;
                this.tpaAnnotation = new TPAAnnotation();
                this.pushed = false;
                this.winningTurn = false;
                this.previousTurn = null;
                this.score = null;
            } 

            showButtons() {
                // Returns the buttons to be displayed
                const buttonIDs = [];
                /* There are 3 phases:
                1) Annotate the balls. If the balls are not annotated (breakPotted === null), show all buttons from 0 to ballsRemaining.
                    1.a) If it's a break (this.breakshot), there are two phases of ball annotation.
                        1.a.1) Annotate the balls potted on the break. (breakPotted === null), show all buttons from 0 to ballsRemaining.
                        1.a.2) Annotate the balls potted on the turn. (breakPotted != null and totalPotted === null), show only buttons 0 and from breakPotted to ballsRemaining. Zero if the cue ball is pocketed.
                2) Main annotation.
                3) Secondary annotation.
                */
                if (this.isWinning() || (this.tpaAnnotation.push)) {
                    if (this.isWinning() && this.previousTurn != null && (this.previousTurn.tpaAnnotation.safeX || this.previousTurn.tpaAnnotation.push || this.previousTurn.tpaAnnotation.safety) && this.tpaAnnotation.kickSequence.length === 0) {
                        buttonIDs.push('buttonK-in');
                    }           
                    return buttonIDs;
                }
                if (!this.tpaAnnotation.ballsAnnotated()) {
                    if (!this.breakShot || this.tpaAnnotation.breakPotted === null) {
                        for (let i = 0; i <= this.ballsRemaining; i++) {
                            buttonIDs.push(`button${i}`);
                        }
                    } else {
                        buttonIDs.push('button0');
                        for (let i = this.tpaAnnotation.breakPotted; i <= this.ballsRemaining; i++) {
                            buttonIDs.push(`button${i}`);
                        }
                    } 
                } else if (!this.tpaAnnotation.noHit && !this.tpaAnnotation.pocketed) {
                    if (this.breakShot && this.tpaAnnotation.totalPotted === 0) {//special case where the break shot didn't pocket anything
                        buttonIDs.push('buttonN');
                        buttonIDs.push('buttonP');
                    } else if (!this.tpaAnnotation.safety && !this.tpaAnnotation.missErrors && !this.tpaAnnotation.kick) {
                        if (this.tpaAnnotation.breakPotted <= this.tpaAnnotation.totalPotted && this.tpaAnnotation.totalPotted > 0) {
                            buttonIDs.push('buttonG');
                            if (this.previousTurn != null && (this.previousTurn.tpaAnnotation.safeX || this.previousTurn.tpaAnnotation.push || this.previousTurn.tpaAnnotation.safety) && this.tpaAnnotation.kickSequence.length === 0) {
                                buttonIDs.push('buttonK-in');
                            }                            
                        }
                        buttonIDs.push('buttonM');
                        buttonIDs.push('buttonK');
                        buttonIDs.push('buttonS');
                    } else {
                        buttonIDs.push('buttonN');
                        buttonIDs.push('buttonP');
                        if (this.tpaAnnotation.safety){
                            console.log("safety");
                            if ((this.breakShot && this.tpaAnnotation.breakPotted === this.tpaAnnotation.totalPotted) || (this.isPushed() && this.tpaAnnotation.totalPotted === 0) || (this.previousTurn != null && this.previousTurn.isBreak() && this.previousTurn.tpaAnnotation.totalPotted === 0 && this.tpaAnnotation.totalPotted === 0)) {//the push is legal on the first shot, so in three cases: 1) break with breakPotted === totalPotted, 2) push turn before pocketing any balls (totalPotted === 0), 3) previous turn was a break with totalPotted === 0 
                                buttonIDs.push('buttonp');
                            }
                            if (this.tpaAnnotation.totalPotted > 0) {
                                buttonIDs.push('buttonx');
                            }
                        } else if (this.tpaAnnotation.missErrors === 1) {
                            buttonIDs.push('buttonN');
                            buttonIDs.push('buttonP');
                            buttonIDs.push('buttonn');
                        }
                    }
                }
                return buttonIDs;
            }

            isBreak() {
                return this.breakShot;
            }

            push() {
                this.pushed = true;
            }

            isPushed() {
                return this.pushed;
            }

            setWinningTurn() {
                this.winningTurn = true;
            }

            isWinning() {
                return this.winningTurn = this.winningTurn || this.ballsRemaining === 0 || this.ballsRemaining === this.tpaAnnotation.totalPotted;
            }

            hasBeenPlayed() {
                return this.tpaAnnotation.ballsAnnotated();
            }

        }

        function updateButtons(turn) {
            const buttonIDs = [];
            const buttonToShow = turn.showButtons();
            // add the ids of the buttons that are inside the scoreButtons div
            // get all the button children of scoreButtons
            const buttons = document.getElementById('scoreButtons').querySelectorAll('button');
            // for each button, add the id to the buttonIDs array
            buttons.forEach(button => buttonIDs.push(button.id));
            // Based on ballsRemaining, hide buttons with an id greater than ballsRemaining. If the button has an id buttonX with X non-numeric, ignore it.
            buttonIDs.forEach(buttonID => {
                if (buttonToShow.includes(buttonID)) {
                    document.getElementById(buttonID).style.display = 'block';
                } else {
                    document.getElementById(buttonID).style.display = 'none';
                }
            });
            
            updateSwitchPlayerStatus();
            document.getElementById('endMatch').classList.remove('d-flex');//controllare??
        }

        function updateLabels(turn) {
            const playerLabel = turn.player === 1 ? 'whiteLabel1' : 'whiteLabel2';
            const grayLabel = turn.player === 1 ? 'grayLabel1' : 'grayLabel2';

            document.getElementById(turn.player === 1 ? 'circle1' : 'circle2').style.border = turn.isWinning() ? "2px solid black" : "none";

            if (turn.player === 1) {//reset of both players' labels
                document.getElementById('whiteLabel2').textContent = '';
                document.getElementById('grayLabel2').textContent = '';
                document.getElementById('circle2').style.border = "none";
                document.getElementById('kicks').textContent = '';
            }

            let whiteLabelText = '';
            if (turn.tpaAnnotation.breakPotted) {//if breakPotted is defined and not null
                whiteLabelText += `<sup>${turn.tpaAnnotation.breakPotted}</sup>`;
            }
            whiteLabelText += `${turn.tpaAnnotation.totalPotted !== null ? (turn.tpaAnnotation.totalPotted >= 0 ? turn.tpaAnnotation.totalPotted : '') : ''}`;
            whiteLabelText += ` ${turn.tpaAnnotation.mainNote()}`;
        
            document.getElementById(playerLabel).innerHTML = whiteLabelText;
        
            document.getElementById(grayLabel).textContent = turn.tpaAnnotation.secondaryNote();

            if (turn.player === 1) {
                document.getElementById('kicks').innerHTML = kickSequence(turn.tpaAnnotation.kickSequence);
            } else {
                if (turn.previousTurn) {
                    document.getElementById('kicks').innerHTML = kickSequence(turn.previousTurn.tpaAnnotation.kickSequence);
                }
                document.getElementById('kicks').innerHTML += kickSequence(turn.tpaAnnotation.kickSequence);
            }
        }
    </script>

    <script>
        let match = null;

        function startMatch() {
            match = new Match(getCookie('player1'),getCookie('player2'));

            document.getElementById('dateTitle').style.display = 'block';
            document.getElementById('main').style.display = 'block';
            document.getElementById('playerForm').style.display = 'none';
            document.getElementById('playerForm').classList.remove('d-flex');
            
            document.getElementById('dateTitle').textContent = match.startDate;
            document.getElementById('player1Label').textContent = match.players[0].name;
            document.getElementById('player2Label').textContent = match.players[1].name;

            const buttons = document.getElementById('scoreButtons').querySelectorAll('button.btn-square');
            // for each button, add match's annotate function as a listener
            buttons.forEach(button => button.addEventListener('click', match.annotate.bind(match)));
            // add a listener to kick-in button that adds the kick sequence on click
            document.getElementById('buttonK-in').addEventListener('click', function() {
                match.getTurn().tpaAnnotation.kickSequence.push(new KickIn(match.currentPlayer, true));
                updateLabels(match.getTurn());
                updateButtons(match.getTurn());
            });

            updateLabels(match.getTurn());
            updateButtons(match.getTurn());
        }

        // Function that takes a list of kick-ins and kick-outs and returns a string with the kick sequence
        function kickSequence(kickIn) {
            let kickSequence = '';
            for (let i = 0; i < kickIn.length; i++) {
                if (kickIn[i].isFirst) 
                    kickSequence += `<span class="circle-kick"><label class="fs-6 col-1">${kickIn[i].player}</label></span>`;
                else
                    kickSequence += `<label class="fs-6 col-1">${kickIn[i].player}</label>`;
            }
            return kickSequence;
        }

        function totalErrors(player) {
            return player.missErrors + player.breakErrors + player.kickErrors + player.safetyErrors + player.positionError;
        }

        function tpaScore(player) {
            return Math.trunc(player.ballsPotted/(player.ballsPotted+totalErrors(player))*1000);
        }

        function scoreToString(score) {
            return `(${score.player1.ballsPotted} , ${totalErrors(score.player1)} , ${tpaScore(score.player1)}) <strong>${score.player1.racksWon} - ${score.player2.racksWon}</strong> (${score.player2.ballsPotted} , ${totalErrors(score.player2)} , ${tpaScore(score.player2)})`;
        }

        function togglePlayer(event) {
            // The id of the clicked element is player1Label or player2Label. I extract the character after player and compare it with the currentPlayer. If it is different, I change the currentPlayer.
            if ((event.target.id === 'player1Label' || event.target.id === 'player2Label') && !event.target.id.includes(match.currentPlayer)) {
                match.togglePlayer();
                updateLabels(match.getTurn());
                updateButtons(match.getTurn());
                //score update
                document.getElementById('score').innerHTML = scoreToString(match.score);
                // If the current turn is a break, show endMatch, otherwise hide it
                if (match.getTurn().isBreak()) {
                    document.getElementById('endMatch').classList.add('d-flex');
                } else {
                    document.getElementById('endMatch').classList.remove('d-flex');
                }
            }
        }
        
        function updateSwitchPlayerStatus() {
            const radioButtons = document.querySelectorAll('#playersGroup input[type="radio"]');
            const labelsForRadioButtons = document.querySelectorAll('#playersGroup label');
            const canSwitch = match.canSwitchPlayer();
        
            // Enable or disable the radio buttons based on the checkbox
            radioButtons.forEach(radio => {
                radio.disabled = !canSwitch;
                if (radio.id === `player${match.currentPlayer}Option`) {
                    radio.checked = true;
                }
            });
                
            // Update the style of the labels to reflect the disabled state
            labelsForRadioButtons.forEach(label => {
                if (!canSwitch) {
                    label.classList.add('disabled');
                } else {
                    label.classList.remove('disabled');
                }
            });
        }

        document.getElementById('playersGroup').addEventListener('click', togglePlayer);
        // Add a click listener to divPlayers that resets the current turn
        document.getElementById('divPlayers').addEventListener('click', function() {
            match.racks[match.currentRack].turns[match.currentTurn].tpaAnnotation.reset();
            updateLabels(match.getTurn());
            updateButtons(match.getTurn());
        });

        function htmlDivAnnotation(turn) {
            let kickSequence = '&nbsp;';
            for (let i = 0; i < turn.tpaAnnotation.kickSequence.length; i++) {
                if (turn.tpaAnnotation.kickSequence[i].player === turn.player) {
                    kickSequence += `<span class="circle-kick"><label class="col-1">${turn.tpaAnnotation.kickSequence[i].player}</label></span>`;
                }
            }
            let whiteLabelText = '';
            if (turn.tpaAnnotation.breakPotted) {//if breakPotted is defined and not null
                whiteLabelText += `<sup>${turn.tpaAnnotation.breakPotted}</sup>`;
            }
            whiteLabelText += `${turn.tpaAnnotation.totalPotted !== null ? (turn.tpaAnnotation.totalPotted >= 0 ? turn.tpaAnnotation.totalPotted : '') : ''}`;
            whiteLabelText += ` ${turn.tpaAnnotation.mainNote()}`;
            let circleBorder = turn.isWinning() ? "2px solid black" : "none";
            return `<div class="mb-1">${kickSequence}</div>
                    <div class="align-items-center">
                        <div class="row">
                            <div class="d-flex justify-content-center">
                                <span class="circle" style="border: ${circleBorder}">
                                    <label class="white-label d-flex">${whiteLabelText}</label>
                                </span>
                                <label class="border gray-label d-flex">${turn.tpaAnnotation.secondaryNote()}</label>
                            </div>
                        </div>
                    </div>`;

        }

        function endMatch() {
            var confirmation = window.confirm("This will end the match. Are you sure?");
          
            if (!confirmation) return;
            // Builds an HTML table with all the turns and annotations
            // Hides main and endMatch, shows results
            // Iterates through all the racks and turns and adds them to the table
            // The table has two columns, one for the first player and one for the second player
            // The headers are the names of the players
            // Each row displays the annotations for the turn
            // At the end of each rack, a wide row with the rack score is added
            const results = document.createElement('table');
            results.classList.add('table');
            results.innerHTML = `
                <thead>
                    <tr>
                        <th scope="col">${match.players[0].name}</th>
                        <th scope="col">${match.players[1].name}</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            `;
            const tbody = results.querySelector('tbody');
            for (let i = 1; i < match.racks.length-1; i++) {//when calling endMatch the last rack is always empty
                let row = document.createElement('tr');
                for (let j = 1; j < match.racks[i].turns.length; j++) {
                    const turn = match.racks[i].turns[j];
                    if (turn.player === 2) {
                        if (j === 1) {
                            row = document.createElement('tr');
                            row.innerHTML = `<td></td><td>${htmlDivAnnotation(turn)}</td>`;
                        } else {// it's not the first turn, so the second player needs to be added to the row
                            row.innerHTML += `<td>${htmlDivAnnotation(turn)}</td>`;
                        }
                    } else {// the player is the first
                        row = document.createElement('tr');
                        row.innerHTML = `<td>${htmlDivAnnotation(turn)}</td>`;                      
                    }
                    tbody.appendChild(row);
                    //if the turn is the last of the rack, add a row with the rack score
                    if (j === match.racks[i].turns.length - 1) {
                        let scoreRow = document.createElement('tr');
                        scoreRow.innerHTML = `<td colspan="2">${turn.score}</td>`;
                        tbody.appendChild(scoreRow);
                    }
                }
            }
            document.getElementById('results').appendChild(results);
            document.getElementById('main').style.display = 'none';
            document.getElementById('endMatch').classList.remove('d-flex');
            document.getElementById('results').style.display = 'block';
        }

    </script>
</body>

</html>